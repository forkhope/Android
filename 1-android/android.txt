                     Android应用知识点积累

Section: 创建并编译Android应用
#### Creating an Android Project ####
An Android project contains all the files that comprise the source code for
your Android app. The Android SDK tools make it easy to start a new Android
project with a set of default project directories and files. 可以通过
Eclipse 或者 命令行 来创建一个Android项目.下面描述通过命令行创建项目的方法:
--> Create a project with Command Line Tools
1. Change directories into the Android SDK's "tools/" path.
2. Execute "android list targets". This prints a list of the available
Android platforms that you've downloaded for your SDK. Find the platform
against which you want to compile your app. Make a note of the target id.
3. Execute "android create project --target <target-id> --name MyFirstApp \
        --path <path-to-workspace>/MyFirstApp --activity MainActivity \
        --package com.example.myfirstapp
Replace <target-id> with an id from the list of targets (from the previous
step) and replace <path-to-workspace> with the location in which you want
to save your Android projects.
Your Android project is now a basic "Hello World" app that contains some
default files.

实际上,这个步骤就是创建了一些目录和文件,并在文件中预置了一些内容.手动创建
这些目录和文件也是可以的,只是麻烦而已.通过Android SDK自带的"android"命令来
创建,更方便. 在一个Android项目中,一般包含如下目录和文件:
--> AndroidManifest.xml
    The manifest file describes the fundamental characteristics of the app
    and defines each of its components. One of the most important elements
    your manifest should include is the <uses-sdk> element. This deslares
    your app's compatibility with different Android versions using the
    "android:minSdkVersion" and "android:targetSdkVersion" attributes. Etc:
<manifest xmlns:android="http://schemas.android.com/apk/res/android" ... >
    <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />
    ...
</manifest>
    Your should always set the "android:targetSdkVersion" as high as
    possible and test your app on the corresponding platform version.
--> src/
    Directory for your app's main source files. By default, it includes an
    Activity class that runs when your app is launched using the app icon.
--> res/
    Contains several sub-directories for app resources. Here are just a few:
    drawable-hdpi/
        Directory for drawable objects (such as bitmaps) that are designed
        for high-density (hdpi) screens. Other drawable directories contain
        assets designed for other screen densities.
    layout/
        Directory for files that define your app's user interface.
    values/
        Directory for other various XML files that contain a collection of
        resources, such as string and color definitions.

#### 在命令行编译Android项目--ant ####
Change directories to the root of your Android project and execute:
    "ant debug"
这里的"ant"命令是一种基于Java的build工具,类似于linux中的make命令.其官方网址
是"http://ant.apache.org/".对该命令的描述如下:
Apache Ant is a Java-based build tool. In theory, it is kind of like make,
without make's wrinkles. 这是一个将软件编译,测试,部署等步骤联系在一起加以
自动化的工具,大多用于Java环境中的软件开发.默认情况下,它的buildfile(XML文件)
名为build.xml.每个buildfile含有一个<project>和至少一个默认的<target>,这些
<target>包含许多task elements.每一个task elements有一个用来被参考的id,此id
必须是唯一的.

--> ant命令的格式: ant [options] [target [target2 [target3] ...]]
介绍部分选项如下(Options):
    -help, -h: 打印帮助信息
    -projecthelp, -p: print project help information. This option prints
        out a list of the build file's targets.
    -debug, -d: print debugging information

--> "ant debug" 和 "ant -debug" 的区别
Android在线网址提到用"ant debug"命令来编译Android Project.而ant有个"-debug"
选项.注意 "ant debug" 和 "ant -debug" 的区别,描述如下:
(1) "ant debug"中的"debug"是编译文件build.xml中定义的目标(target).可以使用
"ant -p"命令来查看当前Android Project下定义的目标,可以看到有如下信息:
    debug       Builds the application and signs it with a debug key.
(2) "ant -debug"中的"-debug"是ant命令的选项,表示"print debugging
information.执行"ant debug"和"ant -debug"所打印的信息完全不同.

--> "ant clean"
如果build.xml中支持"clean"目标,就可以使用ant clean来清理编译文件.注意,ant
命令并没有类似于"clean"的选项,这个目标需要在build.xml中指定.一个例子如下:
<target name="clean" description="Delete all generated files">
    <delete dir="${classes.dir}" failonerror="false"/>
    <delete file="${ant.project.name}.jar"/>
</target>
Android Project的build.xml中定义了 "clean" 目标.

--> Android Project中定义的一些ant目标
在一个Android Project项目下执行 "ant -p" 命令查看它的目标,打印如下:
Buildfile: /home/john/source/workspace/MyFirstApp/build.xml
Main targets:
 clean       Removes output files created by other targets.
 debug       Builds the application and signs it with a debug key.
 install     Installs the newly build package. Must be used in conjunction
             with a build target (debug/release/instrument). If the
             application was previously installed, the application is
             reinstalled if the signature matches.
 installd    Installs (only) the debug package.
 installi    Installs (only) the instrumented package.
 installr    Installs (only) the release package.
 installt    Installs (only) the test and tested packages.
 instrument  Builds an instrumented packaged.
 lint        Runs lint on the project to look for potential bugs
 release     Builds the application in release mode.
 test        Runs tests from the package defined in test.package property
 uninstall   Uninstalls the application from a running emulator or device.
Default target: help
可以看到,默认目标是"help",所以直接在Android Project根目录下执行ant,会打印
当前build.xml中定义的帮助信息.其他常用的目标有安装apk的"install"目标,执行
apk的"test"目标,编译debug代码的"debug"目标,清理编译文件的"clean"目标等.

!!NOTE!!: 如果只执行"ant install"会报错: 'ant install' now requires the
build target to be specified as well. 例如, "ant debug install". 也可以使
用"ant installd"指定要安装"debug package",这样就不用指定"debug"目标了.

!!NOTE!!: 在执行ant test目标时,遇到过这样一个报错: BUILD FAILED. Project is
not a test project. 这是因为"ant test"只能执行定义在"test.package"中的包.
而之前使用"android create projct"语句创建的Android Project并不是具备该属性.
查看项目根目录下的"ant.properties",可以看到里面全是注释.
可以使用"android create test-project"语句来创建一个新的test project,也可以
使用"android update test-project"已经来转换一个已有项目为test project.例如:
  android update test-project -m MyFirstApp/ -p MyFirstTestApp
上面的"-m MyFirstApp"指定了已有项目的根目录,"-p MyFirstTestApp"指定了新的
test project项目的路径.转换之后,进到MyFirstTestApp目录,查看"ant.properties"
文件,里面有这样一句"tested.project.dir=../MyFirstApp/".
奇怪的是,转换之后,执行"ant test"虽然不会报"Project is not a test project"的
错,但是运行时会报着这样一个错: "BUILD FAILED. exec returned: 1"
INSTRUMENTATION_STATUS: Error=Unable to find instrumentation info for:
ComponentInfo{com.example.myfirstapp/android.test.InstrumentationTestRunner}
[exec] INSTRUMENTATION_STATUS_CODE: -1
[exec] android.util.AndroidException: INSTRUMENTATION_FAILED:
    com.example.myfirstapp/android.test.InstrumentationTestRunner
目前猜测,这个test project项目指的是运行单元测试的项目,可能要实现特殊的方法.

#### 编译,安装,并运行Android项目 #### 
(1) ant debug: 编译一个Android项目.
(2) adb install -r bin/apkname: 安装apk文件到机器上,'-r' means reinstall
the app, keepting its data.如果不指定"-r",则重新安装该apk时,会报错.
(3) adb shell am start -n: 在命令行中运行机器上的apk应用.在adb shell中直接
执行 "am" 命令就会打印出它的帮助信息.另外,Android在线网址"http://developer.
android.com/tools/help/adb.html"是adb的帮助手册,里面对am命令做了详细描述:
am start [options] <INTENT>: Start an Activity specified by <INTENT>.
其中, "-n <COMPONENT>" 是 "<INTENT>" 的一种写法,表示: Specify the component
name with package name prefix to create an explicit intent, such as
"com.example.app/.ExampleActivity". "<URI> <COMPONENT> <PACKAGE>"是<INTENT>
的另一种写法: You can directly specify a URI, package name, and compoment
name when not qualified by one of the above options. When an argument is
unqualified, the tool assumes the argument is a URI if it contains a ":"
(colon); it assumes the argument is a component name if it contains a "/"
(forward-slash); otherwise it assumes the argument is a package name.

具体地说,上面的<COMPONENT>的组成为: 包名(package)/[包名].活动名(Activity).
包名和活动名在Android Project的AndroidManifest.xml文件中指定.该文件的
"<manifest>"标签的"package"属性值会指定包名,例如: package="com.example.
myfirstapp".而"<activity>"标签的"android:name"属性值会指定活动名.

!!NOTE!!: 可指定的活动名不局限于被"<action android:name="android.intent.
action.MAIN" />"限定的Activity.其他Activity也是可以的.假设有两个Activity:
<activity android:name="MainActivity" android:label="@string/app_name">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
<activity android:name="DisplayMessageActivity"
    android:label="@string/title_activity_display_message"
    android:parentActivityName="com.example.myfirstapp.MainActivity">
</activity>
则"am start -n com.example.myfirstapp/.MainActivity"会启动MainActivity.而
"am start -n com.example.myfirstapp/.DisplayMessageActivity"会启动
DisplayMessageActivity.

!!NOTE!!: 在指定<INTENT>时,也可以指定intent附带的值,也可以指定intent的标志
位(flags),具体可查看"http://developer.android.com/tools/help/adb.html":
  -f <FLAGS>
    Add flags to the intent, as supported by setFlags().
  --esn <EXTRA_KEY>
    Add a null extra. This option is not supported for URI intents.
  -e|--es <EXTRA_KEY> <EXTRA_STRING_VALUE>
    Add string data as a key-value pair.
  --ez <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE>
    Add boolean data as a key-value pair.
  --ei <EXTRA_KEY> <EXTRA_INT_VALUE>
    Add integer data as a key-value pair.
例如DisplayMessageActivity接收一个String型的附带值,则可以这样启动它:
  am start -n com.example.myfirstapp/.DisplayMessageActivity \
     -e "com.example.myfirstapp.message" "world"
这里的"-e"指定要附带String型的数据,"com.example.myfirstapp.message"数据的名
称,"world"是该名称对应的值.这样指定后,DisplayMessageActivity.java中使用
getStringExtra("com.example.myfirstapp.message")就会返回"world"这个值.

实际验证发现,"am start -n compoent"和"am start component"有所区别.如果一个
Activity正在运行,则执行"am start compoment"再次启动该Activity时,am命令会打
印出这样的警告信息: "Warning: Activity not started, its current task has
been brought to the front".而如果使用"am start -n compoent"来再次启动该
Activity时,不会出现上述的报警信息.

综上所述,可以使用下面的组合命令来编译,安装,并运行一个APK文件.其中,"&&"表示
前一个命令运行成功(即命令返回码为0)时,才会执行下一个命令:
ant debug && adb install -r bin/MyFirstApp-debug.apk && adb shell \
  "am start -n com.example.myfirstapp/com.example.myfirstapp.MainActivity"

根据上面"-n <COMPONENT>"的例子,进一步简化如下:
    ant debug && adb install -r bin/MyFirstApp-debug.apk && \
        adb shell "am start -n com.example.myfirstapp/.MainActivity"
即不用写两遍"com.example.myfirstapp"这个包名.

更进一步,可以使用"ant install"命令来安装编译好的apk文件,不用指定apk路径:
    ant debug install && \
        adb shell "am start -n com.example.myfirstapp/.MainActivity"

Section: Android View组件
#### Building a Simple User Interface ####
The graphical user interface for an Android app is built using a hierarchy
of View and ViewGroup objects. View objects are usually UI widgets such as
buttons or text fields and ViewGroup objects are invisible view containers
that define how the child views are laid out, such as in a grid or a
vertical list.

Android provides an XML vocabulary that corresponds to the subclasses of
View and ViewGroup so you can define your UI in XML using a hierarchy of
UI elements.
                                        -----------
                                        |ViewGroup|
                                        -----------
                                             |
                        ---------------------|-------------------
                        |                    |                  |
                   -----------           --------           --------
                   |ViewGroup|           | View |           | View |
                   -----------           --------           --------
                        |
        ----------------|---------------
        |               |              |
   --------         --------        --------
   | View |         | View |        | View |
   --------         --------        --------
        Figure 1. Illustration of how ViewGroup objects form
        branches in the layout and contain other View objects.

#### LinearLayout ####
LinearLayout is a view group (a subclass of ViewGroup) that lays out child
views in either a vertical or horizontal orientation, as specified by the
"android:orientation" attribute. Each child of a LinearLayout appears on
the screen in the order in which it appears in the XML. For example:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal" >
</LinearLayout>

#### Add a Text Field ####
To create a user-editable text field, add an <EditText> element inside the
<LinearLayout>. Like every View object, you must define certain XML
attributes to specify the EditText object's properties. Here's how you
should declare it inside the <LinearLayout> element:
<EditText android:id="@+id/edit_message"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:hint="@string/edit_message" />

About these attributes:
android:id
  This provides a unique identifier for the view, which you can use to
  reference the object from your app code, such as to read and manipulate
  the object.
  The at sign (@) is required when you're referring to any resource object
  from XML. It is followed by the resource type (id in thie case), a slash,
  then the resource name (edit_message).
  The plus sign (+) before the resource type is needed only when you're
  defining a resource ID for the first time. When you compile the app, the
  SDK tools use the ID name to create a new resource ID in your project's
  gen/R.java file that refers to the EditText element. Once the resource ID
  is declared once this way, other references to the ID do not need the plus
  sign. Using the plus sign is necessary only when specifying a new resource
  ID and not needed for concrete resources such as strings or layouts.
android:layout_width and android:layout_height
  Instead of using specific sizes for the width and height, the
  "wrap_content" value specifies that the view should be only as big as
  needed to fit the content of the view. If you were to instead use
  "match_parent", then the EditText element would fill the screen, because
  it would match the size of the parent LinearLayout.
android:hint
  This is a default string to display when the text field is empty. Instead
  of using a hard-coded string as the value, the "@string/edit_message"
  value refers to a string resource defined in a separate file. Because this
  refers to a concrete resource (not just an identifier), it does not need
  the plus sign. Note: This string resource has the same name as the element
  ID: edit_message. However, references to resources are always scoped by
  the resource type (such as id or string), so using the same name does not
  cause collisions.

--> About resource objects
A resource object is simply a unique integer name that's associated with an
app resource, such as bitmap, layout file, or string.
Eevery resource has a corresponding resource object defined in your
project's gen/R.java file. You can use the object names in the R class to
refer to your resources, such as when you need to specify a string value for
the android:hint attribute. You can also create arbitrary resource IDs that
you associate with a view using the android:id attribute, which allows you
to reference that view from other code.
The SDK tools generate the R.java each time you compile your app. You should
never modify this file by hand.

#### Add String Resources ####
When you need to add text in the user interface, you should always specify
each string as a resource. String resources allow you to manage all UI text
in a single location, which makes it easier to find and update text.
Externalizing the strings also allows you to localize your app to different
languages by providing alternative definitions for each string resource.

By default, your Android project includes a string resource file at
"res/values/strings.xml". Add a new string named "edit_message" and set the
value to "Enter a message." The result of strings.xml looks like this:
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">My First App</string>
    <string name="edit_message">Enter a message</string>
    <string name="title_activity_main">MainActivity</string>
</resources>

#### 描述Android XML文件中 layout_width 和 layout_height 的使用 ####
--> 是否要定义 layout_width 和 layout_height 属性?
Android在线网址
"http://developer.android.com/training/basics/firstapp/building-ui.html"
中提到:
The other two attributes, android:layout_width and android:layout_height,
are required for all views in order to specify their size.

也就是说,在XML文件中定义View组件时,一定要指定 "android:layout_width" 和
"android:layout_height" 属性.
实际调试发现,如果在XML的某个View中不指定这两个属性,例如只写为:
"<TextView android:text="@string/title_activity_main" />".
则编译能通过,不会报错,但是运行时会出错,提示应用已停止运行. adb logcat 中
打印如下信息:
W/dalvikvm(15650): threadid=1: thread exiting with uncaught exception
    (group=0x415feba8)
E/AndroidRuntime(15650): FATAL EXCEPTION: main
E/AndroidRuntime(15650): Process: com.example.myfirstapp, PID: 15650
E/AndroidRuntime(15650): java.lang.RuntimeException: Unable to start
    activity ComponentInfo{com.example.myfirstapp/com.example.myfirstapp.
    MainActivity}: java.lang.RuntimeException: Binary XML file line #8:
    You must supply a layout_width attribute.
E/AndroidRuntime(15650): Caused by: java.lang.RuntimeException: Binary XML
    file line #8: You must supply a layout_width attribute.
W/ActivityManager( 1799): Force finishing activity com.example.
    myfirstapp/.MainActivity

可见,在XML中定义View组件时,确实要指定 "android:layout_width" 和
"android:layout_height" 属性.

--> fill_parent, match_parent, 和wrap_content的区别.
Android在线网址"http://developer.android.com/reference/android/view/
ViewGroup.LayoutParams.html"对这三个值进行了描述:
==========================================================================
| Constant     | Value | Description                                     |
|--------------|-------|-------------------------------------------------|
| fill_parent  |  -1   | The view should be as big as its parent (minus  |
|              |       |     padding). It is replaced by match_parent    |
| match_parent |  -1   | The view should be as big as its parent (minus  |
|              |       |     padding).                                   |
| wrap_content |  -2   | The view should be only big enough to enclose   |
|              |       |     its content (plus padding).                 |
==========================================================================

假设一个xml资源文件中,只有下面两个View:
    <TextView android:text="MainActivity"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent" />
    <EditText android:id="@+id/edit_message"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:hint="Enter a message" />
则运行时,会发现只能看到<TextView>组件,看不到<EditText>组件.应该是因为
<TextView>的宽和高都指定了"fill_parent",导致该组件内容覆盖了父组件的所有
空间,所以看不到<EditText>组件.此时,<TextView>组件所显示的"MainActivity"字
符串位于界面的左上角.
如果将上面<TextView>组件改成 android:layout_height="wrap_content" 的形
式,运行时会发现,还是看不到<EditText>组件,但是<TextView>所显示的
"MainActivity"字符串还是紧挨着左侧,但是降到了界面的中间位置.

如果将<TextView>组件改成android:layout_width="match_parent"和
android:layout_height="match_parent",运行时会发现,还是看不到<EditText>
组件,但是会自动弹出小键盘,应该是<EditText>获得了焦点.此时,<TextView>所
显示的"MainActivity"字符串位于界面的左上角.

如果将<TextView>组件改成android:layout_width="wrap_content"和
android:layout_height="wrap_content",运行时会发现,<TextView>和
<EditText>组件都能显示出来,且自动弹出小键盘,<EditText>组件获得焦点.
此时,这两个组件呈水平排列,紧挨在一起.

--> LinearLayout中的 android:width 和 android:weight
Android在线网址"http://developer.android.com/training/basics/
firstapp/building-ui.html#Weight"中提到: LinearLayout 的weight属性
(android:layout_weight)可以让组件填充屏幕未使用的空间.
The weight value is a number that specifies the amount of remaining space
each view should consume, relative to the amount consumed by sibling views.
This works kind of like the amount of ingredients in a drink recipe: 
"2 parts vodka, 1 part coffee liqueur" means two-third of the drink is
vodka. For example, if you give one view a weight of 2 and another one a
weight of 1, the sum is 3, so the first view fills 2/3 of the remaining
space and the second view fills the rest. If you add a third view and give
it a weight of 1, then the first view (with weight of 2) now gets 1/2 the
remaining space, while the remaining two each get 1/4.

The default weight for all views is 0, so if you specify any weight value
greater than 0 to only one view, then that view fills whatever space
remains after all views are given the space they require. So, to fill the
remaining space in your layout with the EditText element, given it a
weight of 1 and leave the button with no weight.
    '<EditText android:layout_weight="1" ... />'

In order to improve the layout efficiency when you specify the weight, you
should change the width of the EditText to be zero (0dp). Setting the
weight to zero improves layout performance because using "wrap_content" as
the width requires the system to calculate a width that is ultimately
irrelevant because the weight value requires another width calculation to
fill the remaining space.
  '<EditText android:layout_weight="1" android:layout_width="0dp" ... />'
即,Android官方手册推荐是设置了 "layout_weight" 以后,需要再将
"android:layout_width" 设置为 "0dp".

当混合使用"android:weight"和"android:width"时,有如下说明:
(1)将"android:width"设成"match_parent",则"android:weight"越小,占的空间
   越大; "fill_parent"则相反.
(2)将"android:width"设成"wrap_content",则组件之间的比例和
   "android:weight"值所指定的比例不一样.

#### 描述Android XML资源文件中的 android:id 属性 ####
This provides a unique identifier for the view, which you can use to
reference the object from your app code, such as to read and manipulate
the object (you'll see this in the next lesson).
The at sign (@) is required when you're referring to any resource object
from XML. It is followed by the resource type (id in this case), a slash,
then the resource name (edit_message).

The plus sign (+) before the resource type is needed only when you're
defining a resource ID for the first time. When you compile the app, the
SDK tools use the ID name to create a new resource ID in your project's
gen/R.java file that refers to the EditText element. Once the resource ID
is declared once this way, other references to the ID do not need the plus
sign. Using the plus sign is necessary only when specifying a new resource
ID and not needed for concrete resources such as strings or layouts.

即,在XML文件中引用资源对象时,都要使用 '@' 符号.
只有在第一次定义资源ID(resource ID)时,需要使用 '+' 符号.

另外,假设在XML文件中有如下定义:
<EditText android:id="@+id/edit_message"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:hint="@string/edit_message" />
可以看到, "@+id" 和 "@string" 有相同的名字.这个说是可以接受的,描述如下:
This string resource has the same name as the element ID: edit_message.
However, references to resources are always scoped by the resource type
(such as id or string), so using the same name does not cause collisions.

Section: Android Button组件
#### 为<Button>组件添加点击事件 ####
To respond to the button's on-click event, open the layout file and add the
"android:onClick" attribute to the <Button> element:
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/button_send"
        android:onClick="sendMessage" />
The "android:onClick" attribute's value, "sendMessage", is the name of a
method in your activity that the system calls when the user clicks the
button. Etc., Open the MainActivity class and add the corresponding method:
    /** Called when the user clicks the Send button */
    public void sendMessage(View view) {
        // Do something in response to button
    }
In order for the system to match this method to the method name given to
"android:onClick", the signature must be exactly as shown. Specifically,
the method must:
> Be public
> Have a void return value
> Have a View as the only parameter (this will be the View that was clicked)

Section: 使用Android Intent启动其他应用
#### Build an Intent--创建一个Intent ####
An Intent is an object that provides runtime binding between seperate
components (such as two activities). The Intent represents an app's "inten
to do something." You can use the intents for a wide variety of tasks, but
most often they're used to start another activity.
For example, inside a sendMessage() method, create an Intent to start an
activity called DisplayMessageActivity:
    Intent intent = new Intent(this, DisplayMessageActivity.class);
This requires that you import the Intent class:
    import android.content.Intent;
The constructor used here takes two parameters:
> A Context as its first parameter (this(特指上面的this指针) is used
  because the Activity class is a subclass of Context)
> The Class of the app component to which the system should deliver the
  Intent (in this case, the activity that should be started)

An intent not only allows you to start another activity, but it can carry
a bundle of data to the activity as well. Inside the sendMessage() method,
use findViewById() to get the EditText element and add its text value to
the intent:
    Intent intent = new Intent(this, DisplayMessageActivity.class);
    EditText editText = (EditText) findViewById(R.id.edit_message)
    String message = editText.getText().toString();
    intent.putExtra(EXTRA_MESSAGE, message);
Note: You now need an import statement for "android.widget.EditText".
    You'll define the EXTRA_MESSAGE constant in a moment.
An Intent can carry a collection of various data types as key-value pairs
called extras. The putExtra() method takes the key name in the first
parameter and the value in the second parameter. It's generally a good
practice to define keys for intent extras using your app's package name as
a prefix. This ensures they are unique, in case your app interacts with
other apps.

#### Interacting with Other Apps ####
An Android app typically has several activities. Each activity displays a
user interface that allows the user to perform a specific task (such as
view a map or take a photo). To take the user from one activity to another,
your app must use an Intent to define your app's "intent" to do something.
When you pass an Intent to the system with a method such as startActivity(),
the system uses the Intent to identify and start the appropriate app
compontent. Using intents even allows your app to start an activity that is
contained in a separate app.

An Intent can be explicit in order to start a specific component (a
specific Activity instance) or implicit in order to start any component
that can handle the intended action (such as "capture a photo").

#### Sending the User to Another App--传送用户到其它App ####
One of Android's most important features is an app's ability to send the
user to another app based on an "action" it would like to perform. For
example, if your app has the address of a business that you'd like to show
on a map, you don't have to build an activity in your app that shows a map.
Instead, you can create a request to view the address using an Intent. The
Android system then starts an app that's able to show the address on a map.

You must use intents to navigate between activities in your own app. You
generally do so with an explicit intent, which defines the exact class name
of the compoent you want to start. However, when you want to have a
separate app perform an action, such as "view a map," you must use an
implicit intent.

--> Build an Implicit Intent
Implicit intents do not declare the class name of the component to start,
but instread declare an action to perform. The action specifies the thing
you want to do, such as view, edit, send, or get something. Intents often
also include data associated with the action, such as the address you want
to view, or the email message you want to send. Depending on the intent you
want to create, the data might be a Uri, one of several other data types,
or the intent might not need data at all.

If your data is a Uri, there's a simple Intent() constructor you can use
define the action and data. For example, here's how to create an intent to
initiate a phone call using the Uri data to specify the telephone number:
    注意添加 "import android.net.Uri;" 语句来引入 Uri 包.
    Uri number = Uri.parse("tel:5551234");
    Intent callIntent = new Intent(Intent.ACTION_DIAL, number);
When your app invokes this intent by calling startActivity(), the Phone app
initiates a call to the given phone number.

Here are a couple other intents and their action and Uri data pairs:
> View a map:
    // Map point based on address
    Uri location = Uri.parse(
        "geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California");
    // Or map point based on latitude/longitude. z param is zoom level
    // Uri location = Uri.parse("geo:37.422219,-122.08364?z=14");
    Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);
> View a web page:
    Uri webpage = Uri.parse("http://www.android.com");
    Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage);
注意: 这里的网址要以"http://"或"https://"开头,不能只写为"www.android.com",
否则会找不到响应这个 intent 的应用.

Other kinds of implicit intents require "extra" data that provide different
data types, such as a string. You can add one or more piececs of extra data
using the various putExtra() methods.

By default, the system determines the appropriate MIME type required by an
intent based on the Uri data that's included. If you don't include a Uri
in the intent, you should usually use setType() to specify the type of data
associated with the intent. Setting the MIME type further specifies which
kinds of activities should receive the intent. 注意: 每个intent都要指定数据
类型,系统会为Uri数据选择合适的MIME类型,如果没有使用Uri数据,要调用setType()
来设置MIME类型.设置MIME类型能够指定哪些activities能够接收到该intent.例如,
Intent.ACTION_SEND类型的intent,就要指定数据类型(如"image/*", "text/plain"
等),否则会找不到响应该intent的应用.

Here are some more intents that add extra data to specify the desired
action:
> Send an email with an attachment:
  注意添加 "import org.apache.http.protocol.HTTP;" 语句来引入 HTTP 包.
  Intent emailIntent = new Intent(Intent.ACTION_SEND);
  // The intent does not have a URI, so declare the "text/plain" MIME type
  emailIntent.setType(HTTP.PLAIN_TEXT_TYPE);
  emailIntent.putExtra(Intent.EXTRA_EMAIL,
          new String[] {"jon@example.com"}); // recipients
  emailIntent.putExtra(Intent.EXTRA_SUBJECT, "Email subject");
  emailIntent.putExtra(Intent.EXTRA_TEXT, "Email message text");
  emailIntent.putExtra(Intent.EXTRA_STREAM,
          Uri.parse("content://path/to/email/attachment"));
  // You can also attach multiple items by passing an ArrayList of Uris
> Create a calendar event:
  注意添加 "import java.util.Calendar;" 语句来引入 Calendar 包.
  Intent calendarIntent = new Intent(Intent.ACTION_INSERT,
          Events.CONTENT_URI);
  Calendar beginTime = Calendar.getInstance().set(2012, 0, 19, 7, 30);
  Calendar endTime = Calendar.getInstance().set(2012, 0, 19, 10, 30);
  calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME,
          beginTime.getTimeInMillis());
  calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME,
          endTime.getTimeInMillis());
  calendarIntent.putExtra(Events.TITLE, "Ninja class");
  calendarIntent.putExtra(Events.EVENT_LOCATION, "Secret dojo");
  - Note: This intent for a calendar event is supported only with API
        level 14 and higher.

Note: It's important that you define your Intent to be as specific as
possible. For example, if you want to display an image using the
ACTION_VIEW intent, you should specify a MIME type of "image/*". This
prevents apps that can "view" other types of data (like a map app) from
being triggered by the intent. 这里的"as specific as possible"指的是"尽
可能地详细".即,通过设置MIME数据类型来详细描述intent本身的意图.

--> Verify There is an App to Receive the Intent
Although the Android platform guarantees that certain intents will resolve
to one of the built-in apps (such as the Phone, Email, or Calendar app),
you should always include a verification step before invoking an intent.
Caution: If you invoke an intent and there is no app available on the
device that can handle the intent, your app will crash.

To verify there is an activity available that can respond to the intent,
call queryIntentActivities() to get a list of activities capable of
handling your Intent. If the returned List is not empty, you can safely
use the intent, For example:
    import android.content.pm.PackageManager;
    import android.content.pm.ResolveInfo;
    import java.util.List;

    PackageManager packageManager = getPackageManager();
    List<ResolveInfo> activities = packageManager.queryIntentActivities(
            intent, 0);
    boolean isIntentSafe = activities.size() > 0;
If isIntentSafe is true, then at least one app will respond to the intent.
If it is false, then there aren't any apps to handle the intent.

--> Start an Activity with the Intent
Once you have created your intent and set the extra info, call
startActivity() to send it to the system. If the system identifies more
than one activity that can handle the intent, it displays a dialog for the
user to select which app to use. If there is only one activity that handles
the intent, the system immediately starts it.
    startActivity(intent);

Here's a complete example that shows how to create an intent to view a map,
verify that an app exists to handle the intent, then start it:
    // Build the intent
    Uri location = Uri.parse("geo:0,0?q=1600+Amphitheatre+Parkway,
            +Mountain+View,+California");
    Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);

    // Verify it resolves
    PackageManager packageManager = getPackageManager();
    List<ResolveInfo> activities = packageManager.queryIntentActivities(
            mapIntent, 0);
    boolean isIntentSafe = activities.size() > 0;

    // Start an activity if it's safe
    if (isIntentSafe) {
        startActivity(mapIntent);
    }

--> Show an App Chooser
Notice that when you start an activity by passing your intent to
startActivity() and these is more than one app that responds to the intent,
the user can select which app to use by default (by selecting a checkbox at
the bottom of the dialog). This is nice when performing an action for which
the user generally wants to use the same app every time, such as when
opening a web page (uses likely use just one web brower) or taking a photo
(uses likely prefer one camera).

However, if the action to be performed could be handled by multiple apps
and the user might prefer a different app each time--such as a "share"
action, for which users might have several apps through which they might
share an item--you should explicitly show a chooser dialog. The chooser
dialog forces the user to select which app to use for the action every
time (the user cannot select a default app for the action).

To show the chooser, create an Intent using createChooser() and pass it
to startActivity(). For example:
    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.setType(HTTP.PLAIN_TEXT_TYPE);   // 一定要设置数据类型

    // Always use string resources for UI text.
    // This says something like "Share this photo with"
    String title = getResources().getString(R.string.chooser_title);
    // Create intent to show chooser
    Intent chooser = Intent.createChooser(intent, title);

    // Verify the intent will resolve to at least one activity
    if (intent.resolveActivity(getPackageManager()) != null) {
        startActivity(chooser);
    }
注意: 在上述代码中,一定要调用setType()函数来设置数据类型,否则查询到的数目
就会空,即intent.resolveActivity(getPackageManager())语句返回为null.

This displays a dialog with a list of apps that respond to the intent
passed to the createChooser() method and uses the supplied text as the
dialog title.

#### Getting a Result from an Activity ####
Starting another activity doesn't have to be one-way. You can also start
another activity and receive a result back. To receive a result, call
startActivityForResult() (instead of startActivity()).

For example, your app can start a camera app and receive the captured photo
as a result. Or, you might start the People app in order for the user to
select a contact and you'll receive the contact details as a result.

Of course, the activity that responds must be designed to return a result.
When it does, it sends the result as another Intent object. Your activity
receives it in the onActivityResult() callback.
Note: You can use explicit or implicit intents when you call
startActivityForResult(). When starting one of your own activities to
receive a result, you should use an explicit intent to ensure that you
receive the expected result.

--> Start the Activity
There's nothing special about the Intent object you use when starting an
activity for a result, but you do need to pass an additional integer
argument to the startActivityForResult() method.

The integer argument is a "request code" that identifies your request. When
you receive the result Intent, the callback provides the same request code
so that your app can properly identify the result and determine how to
handle it. 即,当前Activity可能会启动多个不同的Activity,但每次回调的都是
onActivityResult()函数,"request code"用于区分所返回的结果对应哪次请求.

For example, here's how to start an activity that allows the user to pick
a contact:
注意添加import android.provider.ContactsContract.CommonDataKinds.Phone;语句
    static final int PICK_CONTACT_REQUEST = 1;  // The request code
    private void pickContact() {
        Intent pickContactIntent = new Intent(Intent.ACTION_PICK,
                Uri.parse("content://contacts"));
        pickContactIntent.setType(Phone.CONTENT_TYPE);
        startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);
    }

--> Receive the Result
When the user is done with the subsequent activity and returns, the system
calls your activity's onActivityResult() method. This method includes
three arguments:
> The request code you passed to startActivityForResult().
> A result code specified by the second activity. This is either RESULT_OK
  if the operation was successful or RESULT_CANCELED if the user backed out
  or the operation failed for some reason.
> An Intent that carries the result data.

For example, here's how you can handle the result for the "pick a contact"
intent:
  @Override
  protected void onActivityResult(int requestCode, int resultCode,
          Intent data) {
      // Check which request we're responding to
      if (requestCode == PICK_CONTACT_REQUEST) {
          // Make sure the request was successful
          if (resultCode == RESULT_OK) {
              // The user picked a contact. The Intent's data Uri
              // identifies which contact was selected.
              // Do something with the contact here (bigger example below)
          }
      }
  }
In this example, the result Intent returned by Android's Contacts or People
app provides a content Uri that identifies the contact the user selected.

In order to successfully handle the result, you must understand what the
format of the result Intent will be. Doing so is easy when the activity
returning a result is one of your own activities. Apps included with the
Android platform offer their own APIs that you can count on for specific
result data. For instance, the People app (Contacts app on some older
versions) always returns a result with the content URI that dientifies the
selected contact, and the Camera app returns a Bitmap in the "data" extra.

Bonus: Read the contact data
The code above showing how to get a result from the People app doesn't go
into details about how to actually read the data from the result, because
it requires more advanced discussion about content providers. However, if
you're curious, here's some more code that shows how to query the result
data to get the phone number from the selected contact:
  @Override
  protected void onActivityResult(int requestCode, int resultCode,
          Intent data) {
      // Check which request it is that we're responding to
      if (requestCode == PICK_CONTACT_REQUEST) {
          // Make sure the request was successful
          if (resultCode == RESULT_OK) {
              // Get the URI that points to the selected contact
              Uri contactUri = data.getData();
              // We only need the NUMBER column, because there will be
              // only one row in the result
              String[] projection = {Phone.NUMBER};

              // Perform the query on the contact to get the NUMBER column
              // We don't need a selection or sort order (there's only one
              // result for the given URI)
              // CAUTION: The query() method should be called from as
              // separate thread to avoid blocking your app's UI thread.
              // (For simplicity of the sample, this code doesn't do that.)
              // Consider using CursorLoader to perform the query.
              Cursor cursor = getContentResolver()
                      .query(contactUri, projection, null, null, null);
              cursor.moveToFirst();

              // Retrieve the phone number from the NUMBER column
              int column = cursor.getColumnIndex(Phone.NUMBER);
              String number = cursor.getString(column);

              // Do something with the phone number...
          }
      }
  }
Note: Before Android 2.3 (API level 9), performing a query on the Contacts
Provider (like the one shown above) requires that your app to declare the
READ_CONTACTS permission. However, beginning with Android 2.3, the
Contacts/People app grants your app a temporary permission to read from the
Contacts Provider when it returns you a result. The temporary permission
applies only to the specific contact requested, so you cannot query a
contact other than the one specified by the intent's Uri, unless you do
declare the READ_CONTACTS permission.

#### Allowing Other Apps to Start Your Activity ####
If your app can perform an action that might be useful to another app, your
app should be prepared to respond to action requests from other apps. For
instance, if you build a social app that can share messages or photos with
the user's friends, it's in your best interest to support the ACTION_SEND
intent so users can initiate a "share" action from another app and launch
your app to perform the action.

To allow other apps to start your activity, you need to add an
<intent-filter> element in your manifest file for the corresponding
<activity> element.

When your app is installed on a device, the system identifies your intent
filters and adds the information to an internal catalog of intents
supported by all installed apps. When an app calls startActivity() or
startActivityForResult(), with an implicit intent, the system finds which
activity (or activities) can respond to the intent.

#### Add an Intent Filter ####
In order to properly define which intents your activity can handle, each
intent filter you add should be as specific as possible in terms of the
type of action and data the activity acceptes.

The system may send a given Intent to an activity if that activity has an
intent filter fulfills the following criteria of the Intent object:
Action
    A string naming the action to perform. Usually one of the platform-
    defined values such as ACTION_SEND or ACTION_VIEW.
    Specify this in your intent filter with the <action> element. The value
    you specify in this element must be the full string name of the action,
    instead of the API constant. 在Intent.java中,有这样的定义:
    public static final String ACTION_SEND = "android.intent.action.SEND";
    即,要求在<action>标签中添加"android.intent.action.SEND"这个字符串,而不
    是添加 ACTION_SEND 这个常量名.
Data
    A description of the data associated with the intent.
    Specify this in your intent filter with the <data> element. Using one
    or more attributes in this element, you can specify just the MIME type,
    just a URI prefix, just a URI scheme, or a combination of these and
    others that indicate the data type accepted.
    - Note: If you don't need to declare specifics about the data Uri (such
      as when your activity handles to other kind of "extra" data, instead
      of a URI), you should specify only the "android:mimeType" attribute
      to declare the type of data your activity handles, such as
      "text/plain" or "image/jpeg".
Category
    Provides an additional way to characterize the activity handling the
    intent, usually related to the user gesture or location from which it's
    started. There are several different categories supported by the
    system, but most are rarely used. However, all implicit intents are
    defined with CATEGORY_DEFAULT by default.
    Specify this in your intent filter with the <category> element.

In your intent filter, you can declare which criteria your activity accepts
by declaring each of them with corresponding XML elements nested in the
<intent-filter> element.

For example, here's an activity with an intent filter that handles the
ACTION_SEND intent when the data type is either text or an image:
    <activity android:name="ShareActivity">
        <intent-filter>
            <action android:name="android.intent.action.SEND"/>
            <category android:name="android.intent.category.DEFAULT"/>
            <data android:mimeType="text/plain"/>
            <data android:mimeType="image/*"/>
        </intent-filter>
    </activity>
Each incoming intent specifies only one action and one data type, but it's
OK to declare multiple instances of the <action>, <category>, and <data>
elements in each <intent-filter>. 在一个<intent-filter>里面,可以同时写多个
<action>, <data>, 和 <category> 标签.

If any two pairs of action and data are mutually exclusive in their
behaviors, you should create separate intent filters to specify which
actions are acceptable when paired with which data types.

For example, suppose your activity handles both text and images for both
the ACTION_SEND and ACTION_SENDTO intents. In this case, you must define
two separate intent filters for the two actions because a ACTION_SEND
intent must use the data Uri to specify the recipient's address using the
send or sendto URI scheme. For example:
    <activity android:name="ShareActivity">
        <!-- filter for sending text; accepts SENDTO action with sms
             URI schemes -->
        <intent-filter>
            <action android:name="android.intent.action.SENDTO"/>
            <category android:name="android.intent.category.DEFAULT"/>
            <data android:scheme="sms" />
            <data android:scheme="smsto" />
        </intent-filter>
        <!-- filter for sending text or images; accepts SEND action
             and text or image data -->
        <intent-filter>
            <action android:name="android.intent.action.SEND"/>
            <category android:name="android.intent.category.DEFAULT"/>
            <data android:mimeType="image/*"/>
            <data android:mimeType="text/plain"/>
        </intent-filter>
    </activity>
Note: In order to receive implicit intents, you must include the
CATEGORY_DEFAULT category in the intent filter. The methods startActivity()
and startActivityForResult() treat all intents as if they declared the
CATEGORY_DEFAULT category. If you do not declare it in your intent filter,
no implicit intents will resolve to your activity.

--> Handle the Intent in Your Activity
In order to decide what action to take in your activity, you can read the
Intent that was used to start it.

As your activity starts, call getIntent() to retrieve the Intent that
started the activity. You can do so at any time during the lifecycle of the
activity, but you should generally do so during early callbacks such as
onCreate() or onStart(). For example:
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);

        // Get the intent that started this activity
        Intent intent = getIntent();
        Uri data = intent.getData();

        // Figure out what to do based on the intent type
        // 实际调试发现,通过Launcher启动该Activity时,intent.getType()函数
        // 会返回null,如果不做判断的话,会触发空指针异常.
        if (intent.getType() != null) {
            if (intent.getType().indexOf("image/") != -1) {
                // Handle intents with image data ...
            } else if (intent.getType().equals("text/plain")) {
                // Handle intents with text ...
            }
        }
    }

--> Return a Result
If you want to return a result to the activity that invoked yours, simply
call setResult() to specify the result code and result Intent. When your
operation is done and the user should return to the original activity, call
finish() to close (and destroy) your activity. For example:
    Intent result = new Intent("com.example.RESULT_ACTION",
        Uri.parse("content://result_uri");
    setResult(Activity.RESULT_OK, result);
    finish();
这里需要执行 finish() 函数.如果不执行该函数,则该Activity被启动后,不会自动
返回调用它的Activity.

You must always specify a result code with the result. Generally, it's
either RESULT_OK or RESULT_CANCELED. You can then provide additional data
with an Intent, as necessary.
Note: The result is set to RESULT_CANCELED by default. So, if the user
presses the Back button before completing the action and before you set
the result, the original activity receives the "canceled" result.
在onActivityResult()回调函数中,会有一个"requestCode"参数,但是,setResult()函
数并没有包含这个参数.应该是系统自动添加"requestCode"到onActivityResult()中.

If you simply need to return an integer that indicates one of several
result options, you can set the result code to any value higher than 0. If
you use the result code to deliver an integer and you have no need to
include the Intent, you can call setResult() and pass only a result code.
For example:
    setResult(RESULT_COLOR_RED);
    finish();
注意: RESULT_OK 的值是 -1.

In this case, there might be only a handful of possible results, so the
result code is a locally defined integer (greater than 0). This works well
when you're returning a result to an activity in your own app, because the
activity that receives the result can reference the public constant to
determine the value of the result code.
Note: There's no need to check whether your activity was started with
startActivity() or startActivityForResult(). Simply call setResult() if the
intent that started your activity might expect a result. If the originating
activity had called startActivityForResult(), then the system delivers it
the result you supply to setResult(); otherwise, the result is ignored.

Section: Android Activity类
#### Start an activity ####
To start an activity, call startActivity() and pass it your Intent. The
system receives this call and starts an instance of the Activity specified
by the Intent.

--> onCreate()函数
All subclasses of Activity must implement the onCreate() method. The system
calls this when creating a new instance of the activity. This method is
where you must define the activity layout with the setContentView() method
and is where you should perform initial setup for the activity components.

--> Add it to the manifest
All activities must be declared in your manifest file, AndroidManifest.xml,
using an <activity> element. It should look like this:
<application ...>
    ...
    <activity
        android:name="com.example.myfirstapp.DisplayMessageActivity"
        android:label="@string/title_activiy_display_message"
        android:parentActivityName="com.example.myfirstapp.MainActivity">
        <meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.example.myfirstapp.MainActivity" />
    </activity>
</application>
如果没有添加"Activity"到"AndroidManifest.xml"文件中,编译能通过,但是运行时
出错,提示应用"已停止运行",出错信息为:
    Caused by: android.content.ActivityNotFoundException: Unable to find
    explicit activity class {com.example.myfirstapp/com.example.myfirstapp.
    DisplayMessageActivity}; have you declared this activity in your
    AndroidManifest.xml?

The "android:parentActivityName" attribute declares the name of this
activity's parent activity within the app's logical hierarchy. The system
uses this value to implement default navigation behaviors, Such as Up
navigation on Android 4.1 (API level 16) and higher. You can provide the
same navigation behaviors for older versions of Android by using the
Support Library and adding the <meta-data> element as shown here.

--> Receive the Intent
Every Activity is invoked by an Intent, regardless of how the user
navigated there. You can get the Intent that started your activity by
calling getIntent() and retrieve the data contained within it.
In the DisplayMessageActivity class's onCreate() method, get the intent
and extract the message delivered by MainActivity:
    Intent intent = getIntent();
    String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE);

--> Display the Message--setContentView()函数
To show the message on the screen, create a TextView widget and set the
text using setText(). Then add the TextView as the root view of the
activity's layout by passing it to setContentView().

For example, the complete onCreate() method for DisplayMessageActivity
looks like this:
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Get the message from the intent
        Intent intent = getIntent();
        String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE);

        // Create the text view
        TextView textView = new TextView(this);
        textView.setTextSize(40);
        textView.setText(message);

        // Set the text view as the activity layout
        setContentView(textView);
    }
下面是"http://developer.android.com/reference/android/app/Activity.html#
setContentView(android.view.View)"在线网址对"setContentView(View)"的描述:
    public void setContentView (View view)
Set the activity content to an explicit view. This view is placed directly
into the activity's view hierarchy. It can itself be a complex view
hierarchy. When calling this method, the layout parameters of the specified
view are ignored. Both the width and the height of the view are set by
default to MATCH_PARENT. To use your own layout parameters, invoke
"setContentView(android.view.View, android.view.ViewGroup.LayoutParams)"
instead.
Parameters
    view    The desired content to display

Section: 在界面中添加ActionBar状态栏
#### Settingup the Action Bar ####
In its most basic form, the action bar displays the title for the activity
and the app icon on the left.
Setting up a basic action bar requires that your app use an activity theme
that enables the action bar. How to request such a theme depends on which
version of Android is the lowest supported by your app.

--> Support Android 3.0 and Above Only
Beginning with Android 3.0 (API level 11), the action bar is included in
all activities that use the Theme.Holo theme (or one of its descendants),
which is the default theme when either the targetSdkVersion or
minSdkVersion attribute is set to "11" or greater.
So to add the action bar to your activities, simple set either attribute
to 11 or higher. For example:
    <manifest ...>
        <uses-sdk android:minSdkVersion="11" ... />
    </manifest>
    Note: If you've created a custom theme, be sure it uses one of the
          Theme.Holo themes as its parent.
Now the Theme.Holo theme is applied to your app and all activities show the
action bar. That's it. 如上所述,当 minSdkVersion 或者 targetSdkVersion 的任
意一个的值大于或等于 "11" 时,就会自动添加Action Bar. 实际验证发现,此时添加
的Action Bar的主题是 Theme.Holo 类型.

如上所述, Theme.Holo 类型默认就带有Action Bar.如果想默认不带Action Bar,可
以设置为android:theme="@android:style/Theme.Holo.NoActionBar".

--> Support Android 2.1 and Above
Adding the action bar when running on versions older than Android (3.0)
(down to Android 2.1) requires that you include the Android Support
Library in your application. 对于这种情况,不做过多描述.

#### Adding Action Buttons ####
The action bar allows you to add buttons for the most important action
items relating to the app's current context. Those that appear directly in
the action bar with an icon and/or text are known as action buttons.
Actions that can't fit in the action bar or aren't important enough are
hidden in the action overflow.

--> Specify the Actions in XML
All action buttons and other items available in the action overflow are
defined in an XML menu resource. To add actions to the action bar, create
a new XML in your project's "res/menu" directory.
Add an <item> element for each item you want to include in the action bar.
For example: "res/menu/main_activity_actions.xml":
<menu xmlns:android="http://schemas.android.com/apk/res/android" >
    <!-- Search, should appear as action button -->
    <item android:id="@+id/action_search"
          android:icon="@drawable/ic_action_search"
          android:title="@string/action_search"
          android:showAsAction="ifRoom" />
    <!-- Settings, should always be in the overflow -->
    <item android:id="@+id/action_settings"
          android:title="@string/action_settings"
          android:showAsAction="never" />
</menu>
This declares that the Search action should appear as an action button when
room is available in the action bar, but the Settings action should always
appear in the overflow. (By default, all actions appear in the overflow,
but it's good practice to explicitly declare your design intentions for
each action). 从这段描述以及实际执行结果来看,点击"overflow"按钮,会弹出来一
个下拉菜单,里面有一项就是"action_settings"这个项,,该项所显示的内容也正好是
"@string/action_settings"这个项所对应的字符串.如果该字符串定义为"Settings",
则显示的就是"Settings". 而"action_search"所定义的那个"android:title"不会显
示出来,如果要在Action Bar上看到这个title的值,需要为"android:showAsAction"
添加上"withText"属性.例如android:showAsAction="ifRoom|withText".注意: 如果
直接写为android:showAsAction="withText",那么这个项将会被放到overflow里面.
如前所述,不加"ifRoom"时,其默认就是显示在overflow中).

android:showAsAction可能的取值为:
    ["ifRoom" | "never" | "withText" | "always" | "collapseActionView"]
注意: 这些取值可以使用 '|' 组合在一起,以指定多个属性值.描述如下:
android:showAsAction: Specify when and how this item should appear as an
action item in the Action Bar. A menu item can appear as an action item
only then the activity includes an ActionBar (introduced in API level 11).
Valid values:
(1) ifRoom: Only place this item in the Action Bar if there is room for it.
(2) withText: Also include the title text (defined by android:title) with
the action item. You can include this value along with one of the others as
a flag set, by separating them with a pipe |.
(3) never: Never place this item in the Action Bar.
(4) always: Always place this item in the Action Bar. Avoid using this
unless it's critical that the item always appear in the action bar. Setting
multiple items to always appear as action items can result in them
overlapping with other UI in the action bar.
(5) collapseActionView: The action view associated with this action item (
as declared by android:actionLayout or android:actionViewClass) is
collapsible. Introduced in API Level 14.

The icon attribute requires a resource ID for an image. The name that
follows @drawable/ must be the name of a bitmap image you've saved in your
project's res/drawable/ directory. For example,"@drawable/ic_action_search"
refers to "ic_action_search.png". Likewise, the title attribute uses a
string resource that's defined by an XML file in your project's
"res/values" directory.
Note: When creating icons and other bitmap images for your app, it's
important that you provide multiple versions that are each optimized for a
different screen density.

即,为了让上面的xml文件能编译通过,还需要进行下面几个步骤:
(1)在"res/drawable"或者"res/drawable-*"目录下添加名为"ic_action_search.png"
的文件,使上面的"android:icon"能够找到该资源文件.
(2)在"res/values/strings.xml"文件中添加"action_search"和"action_settings"
的定义,使上面的"android:title"能够找到对应的字符串资源.例如:
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="action_search">Search</string>
    <string name="action_settings">Just For Setting</string>
</resources>

--> Add the Actions to the Action Bar
To place the menu items into the action bar, implement the
onCreateOptionsMenu() callback method in your activity to inflate the menu
resource into the given Menu object. For example:
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu items for use in the action bar
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.main_activity_actions, menu);
        return super.onCreateOptionsMenu(menu);
    }
上面的R.menu.main_activity_actions关联到res/menu/main_activity_actions.xml
文件,就是通过这种方式来导入该xml文件所定义的项.

--> Respond to Action Buttons
When the user presses one of the action buttons or another item in the
action overflow, the system calls your activity's onOptionsItemSelected()
callback method. In your implementation of this method, call getItemId() on
the given MenuItem to determine which item was pressed -- the returned ID
matches the value you declared in the corresponding <item> element's
"android:id" attribute. For example:
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle presses on the action bar items
        switch (item.getItemId()) {
            case R.id.action_search:
                openSearch();
                return true;
            case R.id.action_settings:
                openSettings();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
代码中,还需要实现 openSearch() 和 openSettings() 这两个函数,根据实际需要
实现即可,如果只是作为测试用,可以实现为空函数,或者打印一些log也行:
    public void openSearch() {
        // do something
    }
    public void openSettings() {
        // do something
    }
另外,编译的时候,需要导入相应的包.如下:
    import android.view.MenuItem;
    import android.view.Menu;
    import android.view.MenuInflater;

--> Add Up Button for Low-level Activities
All screens in your app that are not the main entrance to your app (
activities that are not the "home" screen) should offer the user a way to
navigate to the logical parent screen in the app's hierarchy by pressing
the UP button in the action bar.
When running on Android 4.1 (API level 16) or higher, or when using
ActionBarActivity from the Support Library, performing Up navigation simply
requires that you declare the parent activity in the manifest file and
enable the Up button the action bar. For example, here's how you can
declare an activity's parent in the manifest:
<application ... >
    ...
    <!-- The main/home activity (it has no parent activity) -->
    <activity
        android:name="com.example.myfirstapp.MainActivity" ...>
        ...
    </activity>
    <!-- A child of the main activity -->
    <activity
        android:name="com.example.myfirstapp.DisplayMessageActivity"
        android:label="@string/title_activity_display_message"
        android:parentActivityName="com.example.myfirstapp.MainActivity" >
        <!-- Parent activity meta-data to support 4.0 and lower -->
        <meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.example.myfirstapp.MainActivity" />
    </activity>
</application>
所以,在AndroidManifest.xml文件中声明"android:parentActivityName"属性以及
那个<meta-data>标签,就是为了能用Up按钮导航.

Enable the app icon as the Up button by calling setDisplayHomeAsUpEnabled():
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_displaymessage);
        // For minSdkVersion is 11 or higher:
        getActionBar().setDisplayHomeAsUpEnabled(true);
    }
Because the system now knows MainActivity is the parent activity for
DisplayMessageActivity, when the user presses the Up button, the system
navigates to the parent activity as appropriate -- you do not need to
handle the Up button's event.
目前认为,上面的 onCreate() 函数指的是DisplayMessageActivity.java中的
onCreate()函数. 实际验证发现,即使不执行setDisplayHomeAsUpEnabled()函数也没
有关系,进入DisplayMessageActivity对应的界面后,还是能看到Up按钮.如果执行的是
setDisplayHomeAsUpEnabled(false)语句,那么就会看不到Up按钮.由此猜测,不调用该
函数的情况下,其默认值就是true,即默认会显示Up按钮.

#### Styling the Action Bar ####
If you want to style the action bar to better fit your product brand, you
can easily do so using Android's style and theme resources.
Android includes a few built-in activity themes that include "dark" or
"light" action bar styles. You can also extend these themes to further
customize the look for your action bar.

--> Use an Android Theme
Android includes two baseline activity themes that dictate the color for
the action bar:
    (1) Theme.Holo for a "dark" theme.
    (2) Theme.Holo.Light for a "light" theme.
You can apply these themes to your entire app or to individual activities
by declaring them in your manifest file with the "android:theme" attribute
for the <application> element or individual <activity> elements.
For example:
    <application android:theme="@android:style/Theme.Holo.Light" ... />
You can also use a dark action bar while the rest of the activity uses the
light color scheme by declaring the Theme.Holo.Light.DarkActionBar theme.

--> Customize the Background
To change the action bar background, create a custom theme for your
activity that overrides the actionBarStyle property. This property points
to another style in which you can override the background property to
specify a drawable resource for the action bar background.
If your app uses navigation tabs or the split action bar, then you can also
specify the background for these bars using the backgroundStacked and
backgroundSplit properties, respectively.
  Caution: It's important that you declare an appropriate parent theme from
  which your custom theme and style inherit their styles. Without a parent
  style, your action bar will be without many style properties unless you
  explicitly declare them yourself.

For Android 3.0 and higher only
When supporting Android 3.0 and higher only, you can define the action
bar's background like this: "res/values/themes.xml"
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <!-- the theme applied to the application or activity -->
  <style name="CustomActionBarTheme"
         parent="@android:style/Theme.Holo.Light.DarkActionBar">
      <item name="android:actionBarStyle">@style/MyActionBar</item>
  </style>

  <!-- ActionBar styles -->
  <style name="MyActionBar"
         parent="@android:style/Widget.Holo.Light.ActionBar.Solid.Inverse">
      <item name="android:background">@drawable/actionbar_background</item>
  </style>
</resources>
Then apply your theme to your entire app or individual activities:
    <application android:theme="@style/CustomActionBarTheme" ... />
为了让上面的xml文件能编译通过,需要在"res/drawable"目录下添加一个名为
"actionbar_background.png"的文件,以作为背景色使用,该图片一般是纯色的.也可以
直接将上面的"android:background"指定为纯色(#EE0000表示红色),如下:
    <item name="android:background">#EE0000</item>
实际验证发现,<style name="MyActionBar">中的parent属性必须指定ActionBar.例
如parent="@android:style/Widget.Holo.ActionBar", parent="@android:style/
Widget.Holo.Light.ActionBar".如果只写为parent="@android:style/Widget.Holo",
运行时发现, Action Bar上会看不到内容.原因应该跟上面的"Caution"有关,即没有
适当地继承父类theme,导致丢失了很多样式属性(style properties).

--> Customize the Text Color
To modify the color of text in the action bar, you need to override
separate properties for each text element:
(1) Action bar title: Create a custom style that specifies the textColor
property and specify that style for the titleTextStyle property in your
custom actionBarStyle. Note: The custom style applied to titleTextStyle
should use TextAppearance.Holo.Widget.ActionBar.Title as the parent style.
(2) Action bar tabs: Override actionBarTabTextStyle in your activity theme.
(3) Action buttons: Override actionMenuTextColor in your activity theme.

For Android 3.0 and higher only: When supporting Android 3.0 and higher
only, your style XML file might look like this:
"res/values/themes.xml"
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <!-- the theme applied to the application or activity -->
  <style name="CustomActionBarTheme"
      parent="@android:style/Theme.Holo">
      <item name="android:actionBarStyle">@style/MyActionBar</item>
      <item name="android:actionMenuTextColor">@color/actionbar_text</item>
  </style>

  <!-- ActionBar styles -->
  <style name="MyActionBar"
      parent="@android:style/Widget.Holo.ActionBar">
      <item name="android:background">@drawable/actionbar_background</item>
      <item name="android:titleTextStyle">@style/MyActionBarTitleText</item>
  </style>

  <!-- ActionBar title text -->
  <style name="MyActionBarTitleText"
      parent="@android:style/TextAppearance.Holo.Widget.ActionBar.Title">
      <item name="android:textColor">@color/actionbar_text</item>
  </style>
</resources>
另外,为了让这个XML能编译通过,还需要添加一个"res/values/colors.xml"文件,添
加上面的"@color/actionbar_text"定义,让该值对应一种颜色的值即可:
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="actionbar_text">#ff0000</color>
</resources>

--> Customize the Tab Indicator
在"developer.android.com/training/basics/actionbar/styling.html#CustomTabs"
中有所描述.对于这部分内容,有待验证.

#### Overlaying the Action Bar ####
By default, the action bar appears at the top of your activity window,
slightly reducing the amount of space available for the rest of your
activity's layout. If you want to hide and show the action bar, you can do
so by calling hide() and show() on the ActionBar. However, this causes your
activity to recompute and redraw the layout based on its new size.
代码中,可以调用getActionBar()函数来获取ActionBar对象,则getActionBar().hide()
语句会隐藏Action Bar,而getActionBar().show()语句会显示Action Bar.

To avoid resizing your layout when the action bar hides and shows, you can
enable overlay mode for the action bar. When in overlay mode, your activity
layout uses all the space available as if the action bar is not there and
the system draws the action bar in front of your layout. This obscures some
of the layout at the top, but now when the action bar hides or appears, the
system does not need to resize your layout and the transition is seamless.
    Tip: If you want your layout to be partially visible behind the action
    bar, create a custom style for the action bar with a partially
    transparent background.

--> Enable Overlay Mode
To enable overlay mode for the action bar, you need to create a custom
theme that extends an existing action bar theme and set the
"android:windowActionBarOverlay" property to "true".

For Android 3.0 and higher only: If you minSdkVersion is set to 11 or
higher, your custom theme should use Theme.Holo theme (for one of its
descendants) as your parent theme. For example:
<resources>
    <!-- the theme applied to the application or activity -->
    <style name="CustomActionBarTheme"
           parent="@android:style/Theme.Holo">
        <item name="android:windowActionBarOverlay">true</item>
    </style>
</resources>

--> Specify Layout Top-margin
When the action bar is in overlay mode, it might obscure some of your
layout that should remain visible. To ensure that such items reamin below
the action bar at all times, add either margin or padding to the top of
the view(s) using the height specified by actionBarSize. For example:
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingTop="?android:attr/actionBarSize">
    ...
</RelativeLayout>
实际验证,使用这种方式所定义的组件将会显示在Action Bar的下面.此时,隐藏Action
Bar之后,上面残留一份空白区域.原先Action Bar下面的组件不会提升到界面的上方.
这种方式和不使用Overlay Mode模式时的区别在于: 不使用Overlay Mode模式时,组件
也是显示在Action Bar的下方,但是隐藏Action Bar时,组件会提升到界面的最上方.

Section: 差异化支持(多国语言,多种屏幕等)
#### Supporting Different Languages ####
It's always a good practice to extract UI strings from your app code and
keep them in an external file. Android makes this easy with a resources
directory in each Android project.
If you created your project using the Android SDK Tools, the tools create
a "res/" directory in the top level of the project. Within this "res/"
directory are subdirectories for various resource types. There are also a
few default files such as "res/values/string.xml", which holds your string
values.

--> Create Locale Directories and String Files
To add support for more languages, create additional "values" directories
inside "res/" that include a hyphen and the ISO language code at the end of
the directory name. For example, "values-es" is the directory containing
simple resources for the Locales with the language code "es". Android loads
the appropriate resources according to the locale settings of the device at
run time.

Once you've decided on the languages you will support, create the resource
subdirectories and string resource files. For example:
    MyProject/
        res/
            values/
                strings.xml
            values-es/
                strings.xml
            values-fr/
                strings.xml
Add the string values for each locale into the appropriate file.

At runtime, the Android system uses the appropriate set of string resources
based on the locale currently set for the user's device.
For example, the following are some different string resource files for
different languages.
    English (default locale), "res/values/strings.xml":
        <?xml version="1.0" encoding="utf-8"?>
        <resources>
            <string name="title">My Application</string>
        </resources>
    Spanish, "res/values-es/strings.xml":
        <?xml version="1.0" encoding="utf-8"?>
        <resources>
            <string name="title">Mi Aplicación</string>
        </resources>
Note: You can use the locale qualifier (or any configuration qualifier) on
any resource type, such as if you want to provide localized versions of
your bitmap drawable.

--> Use the String Resources
You can reference your string resources in your source code and other XML
files using the resource name defined by the "<string>" element's "name"
attribute.

In your source code, you can refer to a string resource with the syntex
"R.string.<string_name>". There are a variety methods that accept a string
resource this way. For example:
    // Get a string resource from your app's Resources
    String hello = getResources().getString(R.string.hello_world);

    // Or supply a string resource to a method that requires a string
    TextView textView = new TextView(this);
    textView.setText(R.string.hello_world);
代码中,资源对象是由一个独一无二地整数值来表示."R.string.hello_world"实际上
就是一个 int 型的值.查看编译生成的 "R.java" 就能看到这一点.所以,想要在代码
中引用资源对象时,对应的函数需要接收一个整型参数.我们不能直接引用"R.string.
hello_world"来为String对象赋值.下面的语句是错误的:
    String hello = R.string.hello_world;    // WRONG
另外,上面调用的getResources()函数是Context类的抽象函数,Activity类继承自
ContextThemeWrapper类,该类实现了这个函数,其函数原型以及说明如下:
    public Resources getResources()
        Return a Resources instance for your application's package.

In other XML files, you can refer to a string resource with the syntax
"@string/<string_name>" whenever the XML attribute accepts a string value.
For example:
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello_world" />

--> values-zh, values-zh-rCN, values-zh-rHK, values-zh-rTW
进入Android系统的"设置"-"语言和输入法"-"语言"界面,可以看到里面有三个关于中
文的设置项: 中文(繁体), 中文(简体), 中文(香港).相应的,代码中有三个字符串目
录对应这三个项.除此之外,还有一个通用的中文字符串目录,描述如下:
    values-zh:  通用的中文字符串目录,可能会被后三个目录的内容所覆盖
    values-zh-rCH: 语言选择为"中文(简体)"时所加载的字符串目录
    values-zh-rTW: 语言选择为"中文(繁体)"时所加载的字符串目录
    values-zh-rHK: 语言选择为"中文(香港)"时所加载的字符串目录

当代码中只添加了"values-zh"目录时,不管语言选择为"中文(简体)","中文(繁体)",
还是"中文(香港)",都会加载"values-zh"目录中的字符串.所以称之为通用中文目录.

而"values-zh-rCN", "values-zh-rTW", 和"values-zh-rHK"类似于"values-zh"的子
类,当添加了这三个目录任意一个时,会覆盖"values-zh"的定义. 举例如下:
(1)代码中添加了"values-zh"和"values-zh-rHK"目录时,将语言设置为"中文(繁体)"
和"中文(简体)"会加载"values-zh"目录的字符串,将语言设置为"中文(香港)"会加载
"values-zh-rHK"目录的字符串.
(2)代码中只添加了"values-zh-rHK"目录时,将语言设置为"中文(繁体)"和"中文(简
体)"会加载"value"目录的字符串(即默认的英语),将语言设置为"中文(香港)"时会
加载"value-zh-rHK"目录的字符串.即,"values-zh-rHK"目录只对应"中文(香港)".
(3)代码中添加"values-zh", "values-zh-rCN", "values-zh-rHK", "values-zh-rTW"
目录时,将语言设置为"中文(简体)"会加载"values-zh-rCN"目录的字符串,将语言设
置为"中文(繁体)"会加载"values-zh-rTW"目录的字符串,将语言设置为"中文(香港)"
会加载"values-zh-rHK"目录的字符串.此时,"values-zh"的字符串不会被用到.

#### Supporting Different Screens ####
Android categorizes device screens using two general properties: size and
density. You should include some alternative resources that optimize your
app's appearance for different screen sizes and densities.
(1) There are four generalized sizes: small, normal, large, xlarge
(2) And four generalized densities: low (ldpi), medium (mdpi), high (hdpi),
    extra high (xhdpi)

To declare different layouts and bitmaps you'd like to use for different
screens, you must place these alternative resources in separate
directories, similar to how you do for different language strings.

Also be aware that the screens orientation (landscape or portrait) is
considered a variation of screen size, so many apps should revise the
layout to optimize the user experience in each orientation.

--> Create Different Layouts
To optimize your user experience on different screen sizes, you should
create a unique layout XML file for each screen size you want to support.
Each layout should be saved into the appropriate resources directory, named
with a "-<screen_size>" suffix. For example, a unique layout for large
screens should be saved under "res/layout-large/".
Note: Android automatically scales your layout in order to properly fit the
screen. Thus, your layouts for different screen don't need to worry about
the absolute size of UI elements but instead focus on the layout structure
that affects the user experience (such as the size or position of important
views relative to sibling views).

For example, this project includes a default layout and an alternative
layout for large screens:
    MyProject/
        res/
            layout/
                main.xml
            layout-large/
                main.xml
The file names must be exactly the same, but their contents are different
in order to provide an optimized UI for the corresponding screen size.
Simply reference the layout file in your app as usual:
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }
The system loads the layout file from the appropriate layout directory
based on screen size of the device on which your app is running.

As another example, here's a project with an alternative layout for
landscape orientation:
    MyProject/
        res/
            layout/
                main.xml
            layout-land/
                main.xml
By default, the "layout/main.xml" file is used for portrait orientation.

If you want to provide a special layout for landscape, including while on
large screens, then you need to use both the large and land qualifier:
    MyProject/
        res/
            layout/              # default (portrait)
                main.xml
            layout-land/         # landscape
                main.xml
            layout-large/        # large (portrait)
                main.xml
            layout-large-land/   # large landscape
                main.xml
Note: Android 3.2 and above supports an advanced method of defining screen
size that allows you to specify resources for screen size based on the
minimum width and height in terms of density-independent pixels.

--> Create Different Bitmaps
You should always provide bitmap resources that are properly scaled to each
of the generalized density buckets: low, medium, high and extra-high
density. This helps you achieve good graphical quality and performance on
all screen densities. To generate these images, you should start with your
raw resource in vector format and generate the images for each density
using the following size scales:
    (1) xhdpi: 2.0
    (2) hdpi: 1.5
    (3) mdpi: 1.0 (baseline)
    (4) ldpi: 0.75
This means that if you generate a 200x200 image for xhdpi devices, you
should generate the same resource in 150x150 for hdpi, 100x100 for mdpi,
and 75x75 for ldpi devices.
Then, place the files in the appropriate drawable resource directory:
    MyProject/
        res/
            drawable-xhdpi/
                awesomeimage.png
            drawable-hdpi/
                awesomeimage.png
            drawable-mdpi/
                awesomeimage.png
            drawable-ldpi/
                awesomeimage.png
Any time you reference "@drawable/awesomeimage", the system selects the
appropriate bitmap based on the screen's density.
Note: Low-density (ldpi) resources aren't always necessary. When you
provide hdpi assets, the system scales them down by one half of properly
fit ldpi screens.

#### Supporting Different Platform Versions ####
While the latest versions of Android often provide great APIs for your app,
you should continue to support older versions of Android until more devices
get updated. In order to provide the best features and functionality across
several Android versions, you should use the "Android Support Library" in
your app, which allows you to use several recent platform APIs on older
versions.

--> Specify Minimum and Target API Levels
The AndroidManifest.xml file describes details about yoru app and
identifies which versions of Android it supports. Specifically, the
"minSdkVersion" and "targetSdkVersion" attributes for the "uses-sdk"
element identify the lowest API level with which your app is compatible and
the highest API level against which you've designed and tested your app.
For example:
<manifest xmlns:android="http://schemas.android.com/apk/res/android" ... >
    <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="15" />
    ...
</manifest>
As new versions of Android are released, some style and behaviors may
change. To allow your app to take advantage of these changes and ensure
that your app fits the style of each user's device, you should set the
"targetSdkVersion" value to match the latest Android version available.

--> Check System Version at Runtime
Android provides a unique code for each platform version in the "Build"
constants class. Use these codes within your app to build conditions that
ensure the code that depends on higher API levels is executed only when
those APIs are available on the system.
private void setUpActionBar() {
    // Make sure we're running on Honeycomb or higher to use ActionBar APIs
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        ActionBar actionBar = getActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
    }
}
Note: When parsing XML resources, Android ignores XML attributes that
aren't supported by the current device. So you can safely use XML
attributes that are only supported by newer versions without worrying about
older versions breaking when they encounter that code. For example, if you
set the targetSdkVersion="11", your app includes the ActionBar by default
on Android 3.0 and higher. To then add menu items to the action bar, you
need to set android:showAsAction="ifRoom" in your menu resource XML. It's
safe to do this in a cross-version XML file, because the older versions of
Android simply ignore the showAsAction attribute (this is, you do not need
a separate version in "res/menu-v11/").

--> Use Platform Styles and Themes
Android provides user experience themes that give apps the look and feel of
the underlying operating system. These themes can be applied to your app
within the manifest file. By using these built in styles and themes, your
app will naturally follow the latest look and feel of Android with each new
release.
To make your activity look like a dialog box:
    <activity android:theme="@android:style/Theme.Dialog">
实际运行的时候,会弹出一个对话框窗口,悬浮在应用列表界面上,而不是全屏显示.
To make your activity have a transparent background:
    <activity android:theme="@android:style/Theme.Translucent">
默认背景色是黑色,这样设置后,背景色变成透明,会看到底下的应用列表界面.
To apply your own custom theme defined in "res/values/styles.xml":
    <activity android:theme="@style/CustomTheme">
To apply a theme to your entire app (all activities), add the
"android:theme" attribute to the "<application>" element:
    <application android:theme="@style/CustomTheme">

Section: Activity的生命周期
#### Managing the Activity Lifecycle ####
As a user navigates through, out of, and back to your app, the Activity
instances in your app transition between different states in their
lifecycle. For instance, when your activity starts for the first time, it
comes to the foreground of the system and receives user focus. During this
process, the Android system calls a series of lifecycle methods on the
activity in which you set up the user interface and other components. If
the user performs an action that starts another activity or switches to
another app, the system calls another set of lifecycle methods on your
activity as it moves into the background (where the activity is no longer
visible, but the instance and its state remains intact).

Within the lifecycle callback methods, you can declare how your activity
behaves when the user leaves and reenters the activity. For example, if
you've building a streaming video player, you might pause the video and
terminate the network connection when the user switches to another app.
When the user returns, you can reconnect to the network and allow the user
to resume the video from the same spot.

Ths following explains important lifecycle callback methods that each
Activity instance receives and how you can use them so your activity does
what the user expects and does not consume system resources when your
activity doesn't need them.

#### Starting an Activity ####
Unlike other programming paradigms in which apps are launched with a main()
method, the Android system initiates code in an Activity instance by
invoking specific callback methods that correspond to specific stages of
its lifecycle. There is a sequence of callback methods that start up an
activity and a sequence of callback methods that tear down an activity.

--> Understand the Lifecycle Callbacks
During the life of an activity, the system calls a core set of lifecycle
methods in a sequence similar to a step pyramid. That is, each stage of the
activity lifecycle is a seperate step on the pyramid. As the system creates
a new activity instance, each callback method moves the activity state one
step toward the top. The top of the pyramid is the point at which the
activity is running in the foreground and the user can interact with it.
As the user begins to leave the activity, the system calls other methods
that move the activity staet back down the pyramid in order to dismantle
the activity. In some cases, the activity will move only part way down the
pyramid and wait (such as when the user switches to another app), from
which point the activity can move back to the top (if the user returns to
the activity) and resume where the user left off.
                            -----------
                    +------>| Resumed |---------+
                    |       |(visible)|         |
                    |       -----------      onPause()
                onResume()     ^                |
                    |          |                v
               ----------- onResume() ---------------------
           +-->| Started |     |      |      Paused       |--+
           |   |(visible)|     +------|(partially visible)|  |
  onStart()|   -------^---            ---------------------  |onStop()
           |          |                                +-----+
       -----------  onStart()                     -----v------
   +-->| Created |    |                           | Stopped  |-----+
   |   -----------    +-------onRestart()---------| (hidden) |     |
 onCreate()                                       ------------ onDestroy()
   |                                                               |
------------                                                  -----v-------
| Activity |                                                  | Destroyed |
------------                                                  -------------
Figure 1. A simplified illustration of the Activity lifecycle, expressed as
a step pyramid. This shows how, for every callback used to take the
activity a step toward the Resumed state at the top, there's a callback
method that takes the activity a step down. The activity can also return
to the resumed state from the Paused and Stopped state.

Depending on the complexity of your activity, you probably don't need to
implement all the lifecycle methods. However, it's important that you
understand each one and implement those that ensure your app behaves the
way users expect. Implementing your activity lifecycle methods properly
ensures your app behaves well in several ways, including that it:
> Does not crash if the user receives a phone call or switches to another
  app while using your app.
> Does not consume valuable system resources when the user is not actively
  using it.
> Does not lose the user's progress if they leave your app and return to
  it at a later time.
> Does not crash or lose the user's progress when the screen rotates
  between landscape and portrait orientation.

As you'll learn in the following lessons, there are several situations in
which an activity transitions between different states that are illustrated
in figure 1. However, only three of these states can be static. That is,
the activity can exist in one of only three states for an extended period
of time:
Resumed
    In this state, the activity is in the foreground and the user can
    interact with it. (Also sometimes referred to as the "running" state.)
Paused
    In this state, the activity is partially obscured by another activity--
    the other activity that's in the foreground is semi-transparent or
    doesn't cover the entire screen. The paused activity does not receive
    user input and cannot execute any code.
Stopped
    In this state, the activity is completely hidden and not visible to the
    user; it is considered to be in the background. While stopped, the
    activity instance and all its state information such as member
    variables is retained, but it cannot execute any code.

The other states (Created and Started) are transient and the system quickly
moves from them to the next state by calling the next lifecycle callback
method. That is, after the system calls onCreate(), it quickly calls
onStart(), which is quickly followed by onResume().

--> Specify Your App's Launcher Activity
When the user selects your app icon from the Home screen, the system calls
the onCreate() method for the Activity in your app that you've declared to
be the "launcher" (or "main") activity. This is the activity that serves
as the main entry point to your app's user interface.
You can define which activity to use as the main activity to use as the
main activity in the Android manifest file, AndroidManifest.xml, which is
at the root of your project directory. The main activity for you app must
be declared in the manifest with an "<intent-filter>" that includes the
"MAIN" action and "LAUNCHER" category. For example:
  <activity android:name=".MainActivity" android:label="@string/app_name">
      <intent-filter>
          <action android:name="android.intent.action.MAIN" />
          <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
  </activity>
Note: When you create a new Android project with the Android SDK tools,
the default project files include an Activity class that's declared in the
manifest with this filter.
If either the "MAIN" action or "LAUNCHER" category are not declared for one
of your activities, then your app icon will not appear in the Home screen's
list of apps.

--> Create a New Instance
Most apps include several different activities that allow the user to
perform different actions. Whether an activity is the main activity that's
created when the user clicks your app icon or a different activity that
your app starts in response to a user action, the system creates every
new instance of Activity by calling its onCreate() method.

You must implement the onCreate() method to perform basic application
startup logic that should happen only once for the entire life of the
activity. For example, your implementation of onCreate() should define the
user interface and possibly instantiate some class-scope variables.
即, onCreate() 函数应该进行那些只初始化一次的操作.

For example, the following example of the onCreate() method shows some code
that performs some fundamental setup for the activity, such as declaring
the user interface (defined in an XML layout file), defining member
variables, and configuring some of the UI.
>>>>>>>>>>>>>>>>>>>>>>>>> Begin of onCreate() <<<<<<<<<<<<<<<<<<<<<<<<<
TextView mTextView; // Member variable for text view in the layout
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Set the user interface layout for this Activity. The layout file is
    // defined in the project "res/layout/main_activity.xml" file.
    setContentView(R.layout.main_activity);
    
    // Initialize member TextView so we can manipulate it later
    mTextView = (TextView) findViewById(R.id.text_message);
    
    // Make sure we're running on Honeycomb or higher to use ActionBar APIs
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        // For the main activity, make sure the app icon in the action bar
        // does not behave as a button
        ActionBar actionBar = getActionBar();
        actionBar.setHomeButtonEnabled(false);
    }
}
>>>>>>>>>>>>>>>>>>>>>>>>> End of onCreate() <<<<<<<<<<<<<<<<<<<<<<<<<

Once the onCreate() finishes execution, the system calls the onStart() and
onResume() methods in quick succession. Your activity never resides in the
Created or Started states. Technically, the activity becomes visible to
the user when onStart() is called, but onResume() quickly follows and the
activity remains in the Resumed state until something occurs to change
that, such as when a phone call is received, the user navigates to another
activity, or the device screen turns off.
The onStart() and onResume() are useful during your activity's lifecycle
when used to resume the activity from the Paused or Stopped states.

--> Destroy the Activity
While the activity's first lifecycle callback is onCreate(), its very last
callback is onDestroy(). The system calls this method on your activity as
the final signal that your activity instance is being completely removed
from the system memory.
Most apps don't need to implement this method because local class
references are destroyed with the activity and your activity should perform
most cleanup during onPause() and onStop(). However, if your activity
includes background threads that you created during onCreate() or other
long-running resources that could potentially leak memory if not properly
closed, you should kill them during onDestroy().
    @Override
    public void onDestroy() {
        super.onDestroy();  // Always call the superclass
        
        // Stop method tracing that the activity started during onCreate()
        android.os.Debug.stopMethodTracing();
    }
Note: The system calls onDestroy() after it has already called onPause()
and onStop() in all situations except one: when you call finish() from
within the onCreate() method. In some cases, such as when your activity
operates as a temporary decision maker to launch another activity, you
might call finish() from within onCreate() to destroy the activity. In this
case, the system immediately calls onDestroy() without calling any of the
other lifecycle methods.

#### Pausing and Resuming an Activity
During normal app use, the foreground activity is sometimes obstructed by
other visual components that cause the activity to pause. For example, when
a semi-transparent activity opens (such as one in ths style of a dialog),
the previous activity pauses. As long as the activity is still partially
visible but currently not the activity in focus, it remains paused.
However, once the activity is fully-obstructed and not visible, it stops.
即,当 Activity 的界面部分可见,但焦点不在它身上时,它处于 Paused 状态.例如启
动一个对话框类型(android:theme="@android:style/Theme.Dialog)的Activity,由于
对话框Activity不是全屏的,其底下的Activity就是"部分可见",此时底下的Activity
处于 Paused 状态.如果新启动一个全屏的Activity,则底下的Activity完全不可见,它
会处于 Stopped 状态.实际加log调试,确认就是这个流程.

As your activity enters the paused state, the system calls the onPause()
method on your Activity, which allows your to stop ongoing actions that
should not continue while paused (such as a video) or persist any
information that should be permanently saved in case the user continues to
leave your app. If the user returns to your activity from the paused state,
the system resumes it and calls the onResume() method.
When a semi-transparent activity obscures your activity, the system calls
onPause() and the activity waits in the Paused state. If the user returns
to the activity while it's still paused, the system calls onResume().
Note: When your activity receives a call to onPause(), it may be an
indication that the activity will be paused for a moment and the user may
return focus to your activity. However, it's usually the first indication
that the user is leaving your activity.

--> Pause Your Activity
When the system calls onPause() for your activity, it technically means
your activity is still partially visible, but most often is an indication
that the user is leaving the activity and it will soon enter the Stopped
state. You should usually use the onPause() callback to:
> Stop animations or other ongoing actions that could consume CPU.
> Commit unsaved changes, but only if users expect such changes to be
  permanently saved when they leave (such as a draft email).
> Release system resources, such as broadcast receivers, handles to sensors
  (like GPS), or any resources that may affect battery life while your
  activity is paused and the user does not need them.

For example, if your application uses the Camera, the onPause() method is
a good place to release it.
    @Override
    public void onPause() {
        super.onPause();  // Always call the superclass method first
    
        // Release the Camera because we don't need it when paused
        // and other activities might need to use it.
        if (mCamera != null) {
            mCamera.release()
            mCamera = null;
        }
    }
Generally, you should not use onPause() to store user changes (such as
personal information entered into a form) to permanent storage. The only
time you should persist user changes to permanent storage within onPause()
is when you're certain users expect the changes to be auto-saved (such as
when drafting an email). However, you should avoid performing CPU-intensive
work during onPause(), such as writing to a database, because it can slow
the visible transition to the next actity (you should instead perform
heavy-load shutdown operations during onStop()).

You should keep the amount of operations done in the onPause() method
relatively simple in order to allow for a speedy transition to the user's
next destination if your activity is actually being stopped.
Note: When your activity is paused, the Activity instance is kept resident
in memory and is recalled when the activity resumes. You don't need to
re-initialize components that were created during any of the callback
methods leading up to the Resumed state.

--> Resume Your Activity
When the user resumes your activity from the Paused state, the system calls
the onResume() method.
Be aware that the system calls this method every time your activity comes
into the foreground, including when it's created for the first time. As
such, you should implement onResume() to initialize components that you
release during onPause() and perform any other initializatioins that must
occur each time the activity enters the Resumed state (such as begin
animations and initialize components only used while the activity has user
focus).

The following example of onResume() is the counterpart to the onPause()
example above, so it initializes the camera that's released when the
activity pauses.
    @Override
    public void onResume() {
        super.onResume();  // Always call the superclass method first
    
        // Get the Camera instance as the activity achieves full user focus
        if (mCamera == null) {
            initializeCamera(); // Local method to handle camera init
        }
    }

#### Stopping and Restarting an Activity ####
There are a few of key scenarios in which your activity is stopped and
restarted:
> The user opens the Recent Apps window and switches from your app to
another app. The activity in your app that's currently in the foreground
is stopped. If the user returns to your app from the Home screen launcher
icon or the Recent Apps window, the activity restarts.
> The user performs an action in your app that starts a new activity. The
current activity is stopped when the second activity is created. If the
user then presses the Back button, the first activity is restarted.
> The user receives a phone call while using your app on his or her phone.

The Activity class provides two lifecycle methods, onStop() and onResume(),
which allow you to specifically handle how your activity handles being
stopped and restarted. Unlike the paused state, which identifies a partial
UI obstruction, the stopped state guarantees that the UI is no loger
visible and the user's focus is in a separate activity (or en entirely
separate app).
Note: Because the system retains your Activity instance in system memory
when it is stopped, it's possible that you don't need to implement the
onStop() and onRestart() (or even onStart() methods at all). For most
activities that are relatively simple, the activity will stop and restart
just fine and you might only need to use onPause() to pause ongoing actions
and disconnect from system resources.

When the user leaves your activity, the system calls onStop() to stop the
activity. If the user returns while the activity is stopped, the system
calls onRestart(), quickly followed by onStart() and onResume(). Notice
that no matter what scenario cuases the activity to stop, the system always
calls onPause() before calling onStop().

--> Stop Your Activity
When your activity receives a call to the onStop() method, it's no longer
visible and should release almost all resources that aren't needed while
the user is not using it. Once your activity is stopped, the system might
destroy the instance if it needs to recover system memory. In extreme
cases, the system might simply kill your app process without calling the
activity's final onDestroy() callback, so it's important you use onStop()
to release resources that might leak memory.

Although the onPause() method is called before onStop(), you should use
onStop() to perform larger, more CPU intensive shut-down operations, such
as writing information to a database.
For example, here's an implementation of onStop() that saves the contents
of a draft note to persistent storage:
@Override
protected void onStop() {
    super.onStop();  // Always call the superclass method first

    // Save the note's current draft, because the activity is stopping
    // and we want to be sure the current note progress isn't lost.
    ContentValues values = new ContentValues();
    values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText());
    values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle());

    getContentResolver().update(
        mUri,    // The URI for the note to update.
        values,  // The map of column names and new values to apply to them
        null,    // No SELECT criteria are used.
        null     // No WHERE columns are used.
        );
}

When your activity is stopped, the Activity object is kept resident in
memory and is recalled when the activity resumes. You don't need to
re-initialize components that were created during any of the callback
methods leading up to the Resumed state. The system also keeps track of the
current state for each View in the layout, so if the user entered text into
an EditText widget, that content is retained so you don't need to save and
restore it.
Note: Even if the system destroys your activity while it's stopped, it
still retains the state of the View objects (such as text in an EditText)
in a Bundle (a blob of key-value pairs) and restores them if the user
navigates back to the same instance of the activity.
实际调试发现,当 Activity 停留在 onStop() 状态,再执行onRestart()->onStart()
->onResume()恢复时, EditText 中的内容会被保留.如果执行过onDestroy()函数,再
执行onCreate()函数恢复时, EditText 中的内容不会被保留.
从当前Activity启动第二个Activity时,上一个Activity会处于 onStop() 状态.此时,
若点击"Back"按钮退回上一个Activity,会执行onRestart()函数,EditText中的内容还
保留.若点击"Up"导航按钮退回上一个Activity,会先执行onDestroy()函数摧毁上一个
Activity,再执行onCreate()创建新的Activity,EditText中的内容会被清空.

#### Start/Restart Your Activity ####
When your activity comes back to the foreground from the stopped state, it
receives a call to onRestart(). The system also calls the onStart() method,
which happens every time your activity becomes visible (whether being
restarted or created for the first time). The onRestart() method, however,
is called only when the activity resumes from the stopped state, so you can
use it to perform special restoration work that might be necessary only if
the activity was previously stopped, but not destroyed.

It's uncommon that an app needs to use onRestart() to restore the
activity's state. However, because your onStop() method should essentially
clean up all your activity's resources, you'll need to re-initiate them
when the activity restarts. Yet, you also need to instantiate them when
your activity is created for the first time (when there's no existing
instance of the activity). For this reason, you should usually use the
onStart() callback method as the counterpart to the onStop() method,
because the system calls onStart() both when it creates your activity and
when it restarts the activity from the stopped state.
For example, because the user might have been away from your app for a long
time before coming back it, the onStart() method is a good place to verify
that required system features are enabled:
@Override
protected void onStart() {
    super.onStart();  // Always call the superclass method first
    
    // The activity is either being restarted or started for the first time
    // so this is where we should make sure that GPS is enabled
    LocationManager locationManager = 
            (LocationManager) getSystemService(Context.LOCATION_SERVICE);
    boolean gpsEnabled = locationManager.isProviderEnabled(
            LocationManager.GPS_PROVIDER);
    
    if (!gpsEnabled) {
        // Create a dialog here that requests the user to enable GPS, and
        // use an intent with the 
        // android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS action
        // to take the user to the Settings screen to enable GPS when they
        // click "OK"
    }
}

@Override
protected void onRestart() {
    super.onRestart();  // Always call the superclass method first
    
    // Activity being restarted from stopped state    
}

When the system destroys your activity, it calls the onDestroy() method for
your Activity. Because your should generally have release most of your
resources with onStop(), by the time you receive a call to onDestroy(),
there's not much that most apps need to do. This method is your last chance
to clean out resources that could lead to memory leak, so you should be
sure that additional threads are destroyed and other long-running actions
like method tracing are also stopped.

#### Recreating an Activity ####
There are a few scenarios in which your activity is destroyed due to normal
app behavior, such as when the user presses the Back button or your
activity signals its own destruction by calling finish(). The system may
also destroy your activity if it's currently stopped and hasn't been used
in a long time or the foreground activity requires more resources so the
system must shut down background processes to recover memory.
When your activity is destroyed because the user presses Back or the
activity finishes itself, the system's concept of that Activity instance is
gone forever because the behavior indicates the activity is no longer
needed. However, if the system destroys the activity due to system
constraints (rather than normal app behavior), then although the actual
Activity instance is gone, the system remembers that is existed such that
if the user navigates back to it, the system creates a new instance of the
activity using a set of saved data that describes the state of the activity
when it was destroyed. The saved data that the system uses to restore the
previous state is called the "instance state" and is a collection of
key-value pairs stored in a Bundle object.
Caution: Your activity will be destroyed and recreated each time the user
rotates the screen, When the screen changes orientation, the system
destroys and recreates the foreground activity because the screen
configuration has changed and your activity might need to load alternative
resources (such as the layout).

By default, the system uses the Bundle instance state to save information
about each View object in your activity layout (such as the text value
entered into an EditText object). So, if your activity instance is
destroyed and recreated, the state of the layout is restored to its
previous state with no code required by you. However, your activity might
have more state information that you'd like to restore, such as member
variables that track the user's progress in the activity.
!!Note!!: In order for the Android system to restore the state of the views
in your activity, each view must have a unique ID, supplied by the
"android:id" attribute.

实际验证发现,当点击"Back"键退出Activity,再重新进入时,系统传递给onCreate()
函数的savedInstanceState参数总是null,而按照上面的警告,旋转屏幕会重新调用
onCreate()函数,此时传递过来的savedInstanceState参数就不是null.即,这里描述
的"Recreating an Activity"的概念不包括点击"Back"退出Activity再进入的情况,而
是指由于系统资源或内存等的限制,导致后台Activity被系统摧毁,此时该Activity的
一些状态被系统保留,当再次进入该Activity时,所保留的状态被传递给Activity,以供
恢复.如上所述,系统默认保存和恢复指定了ID的 View 对象的状态.当在EditText中
输入一些内容后,转动屏幕,这些内容还会保留.但是点击"Back"键退出,再进入后,这些
内容会被清空.

To save additional data about the activity state, you must override the
onSaveInstanceState() callback method. The system calls this method when
the user is leaving your activity and passes it the Bundle object that will
be saved in the event that your activity is destroyed unexpectedly. If the
system must recreate the activity instance later, it passes the same Bundle
object to both the onRestoreInstanceState() and onCreate() methods.
    -------------                                -------------
    |  Resumed  |                                |           |
    | (visible) |-------onSaveInstanceState()--->| Destroyed |
    -------------                                -------------

    ------------
    | Activity |
    ------------
         |
     onCreate()
         |                                         -------------
    -----v-----                                    |  Resumed  | 
    | Created |---------onRestoreInstanceState()-->| (visible) |
    -----------                                    -------------
Figure 2. As the system begins to stop your activity, it calls
onSaveInstanceState() so you can specify additional state data you'd like
to save in case the Activity instance must be recreated. If the activity
is destroyed and the same instance must be recreated, the system passes the
state data defined at both the onCreate() method and the
onRestoreInstanceState() method.

--> Save Your Activity State
As your activity begins to stop, the system calls onSaveInstanceState() so
your activity can save state information with a collection of key-value
pairs. The default implementation of this method saves information about
the state of the activity's view hierarchy, such as the text in an EditText
widget or the scroll position of a ListView.

To save additional state information for you activity, you must implement
onSaveInstanceState() and add key-value pairs to the Bundle object. 实际调
试发现,执行onPause()函数后,就会执行onSaveInstanceState()函数. For example:
  static final String STATE_SCORE = "playerScore";
  static final String STATE_LEVEL = "playerLevel";
  ...
  
  @Override
  public void onSaveInstanceState(Bundle savedInstanceState) {
      // Save the user's current game state
      savedInstanceState.putInt(STATE_SCORE, mCurrentScore);
      savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);
      
      // Always call the superclass so it can save the view hierarchy state
      super.onSaveInstanceState(savedInstanceState);
  }
Caution: Always call the superclass implementation of onSaveInstanceState()
so the default implementation can save the state of the view hierarchy.

--> Restore Your Activity State
When your activity is recreated after it was previously destroyed, you can
recover your saved state from the Bundle that the system passes your
activity. Both the onCreate() and onRestoreInstanceState() callback methods
receive the same Bundle that contains the instance state information.

Because the onCreate() method is called whether the system is creating a
new instance of your activity or recreating a previous one, you must check
whether the state Bundle is null before you attempt to read it. If it is
null, then the system is creating a new instance of the activity, instead
of restoring a previous one that was destroyed.
For example, here's how you can restore some state data in onCreate():
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState); // Always call the superclass first
   
    // Check whether we're recreating a previously destroyed instance
    if (savedInstanceState != null) {
        // Restore value of members from saved state
        mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
        mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
    } else {
        // Initialize members with default values for a new instance
    }
    ...
}

Instead of restoring the state during onCreate() you may choose to
implement onRestoreInstanceState(), which the system calls after the
onStart() method. The system calls onRestoreInstanceState() only if there
is a saved state to restore, so you do not need to check whether the
Bundle is null:
  public void onRestoreInstanceState(Bundle savedInstanceState) {
      // Always call the superclass so it can restore the view hierarchy
      super.onRestoreInstanceState(savedInstanceState);
     
      // Restore state members from saved instance
      mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
      mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
  }
Caution: Always call the superclass implementation of
onRestoreInstanceState() so the default implementation can restore the
state of the view hierarchy.

创建一个新的Activity时,执行的函数顺序是:
  onCreate()->onStart()->onResume(). 不会执行onRestoreInstanceState()函数
点击"Home"键返回主界面时,该Activity执行的函数顺序是:
  onPause()->onSaveInstanceState()->onStop().
从主界面返回Activity时,执行的函数顺序是:
  onRestart()->onStart()->onResume(). 此时EditText中的内容会保留.
点击"Back"键退出Activity时,执行的函数顺序是:
  onPause()->onStop()->onDestroy(). 此时在onPause()之后不会执行
  onRestoreInstanceState()函数,即系统不保存Activity的状态.
点击"Back"键退出Activity"后,再次创建该Activity的函数执行顺序是:
  onCreate()->onStart()->onResume(). 此时, 传递给onCreate()函数的
  savedInstanceState参数的值是null. 因为上一个步骤并没有保存Activity状态.
进入Activity后,旋转屏幕的函数执行顺序是:
  onPause()->onSaveInstanceState()->onStop()->onDestroy()->onCreate()
  ->onStart()->onRestoreInstanceState()->onResume(). 此时,传递给onCreate()
  和onRestoreInstanceState()的savedInstanceState参数不是null.

Section: Android Fragment类
#### Building a Dynamic UI with Fragments ####
To create a dynamic and multi-pane user interface on Android, you need to
encapsulate UI components and activity behaviors into modules that you can
swap into and out of your activities. You can create these modules with the
Fragment class, which behaves somewhat like a nested activity that can
define its own layout and manage its own lifecycle.

When a fragment specifies its own layout, it can be configured in different
combinations with other fragments inside an activity to modify your layout
configuration for different screen sizes (a small screen might show one
fragment at a time, but a large screen can show two or more).

#### Creating a Fragment ####
You can think of a fragment as a modular section of an activity, which has
its own lifecycle, receives its own input events, and which you can add or
remove while the activity is running (sort of like a "sub activity" that
you can reuse in different activities).
Note: If you decide that the minimum API level your app requires is 11 or
higher, you don't need to use the Support Library and can instead use the
framework's built in Fragment class and related APIs.

--> Create a Fragment Class
To create a fragment, extend the Fragment class, then override key
lifecycle methods to insert your app logic, similar to the way you would
with an Activity class.

One difference when creating a Fragment is that you must use the
onCreateView() callback to define the layout. In fact, this is the only
callback you need in order to get a fragment running. For example, here's
a simple fragment that specifies its own layout:
  import android.os.Bundle;
  import android.app.Fragment;
  import android.view.LayoutInflater;
  import android.view.ViewGroup;
  
  public class ArticleFragment extends Fragment {
      @Override
      public View onCreateView(LayoutInflater inflater,
              ViewGroup container, Bundle savedInstanceState) {
          // Inflate the layout 'article_view.xml' for this fragment
          return inflater.inflate(R.layout.article_view, container, false);
      }
  }
Just like an activity, a fragment should implement other lifecycle
callbacks that allow you to manage its state as it is added or removed from
the activity and as the activity transitions between its lifecycle states.
For instance, when the activity's onPause() method is called, any fragments
in the activity also receive a call to onPause().

--> Add a Fragment to an Activity using XML
While fragments are reusable, modular UI components, each instance of a
Fragment class must be associated with a parent FragmentActivity or
Activity. You can achieve this association by defining each fragment within
your activity layout XML file.
Note: FragmentActivity is a special activity provided in the Support
Library to handle fragments on system versions older than API level 11. If
the lowest system version you support is API level 11 or higher, then you
can use a regular Activity.

Here is an example layout file that adds two fragments to an activity when
the device screen is considered "large" (specified by the "large" qualifier
in the directory name).
>>>> res/layout-large/news_articles.xml <<<<
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">

    <fragment android:name="com.example.android.fragments.HeadlinesFragment"
              android:id="@+id/headlines_fragment"
              android:layout_weight="1"
              android:layout_width="0dp"
              android:layout_height="match_parent" />

    <fragment android:name="com.example.android.fragments.ArticleFragment"
              android:id="@+id/article_fragment"
              android:layout_weight="2"
              android:layout_width="0dp"
              android:layout_height="match_parent" />

</LinearLayout>
Then apply the layout to your activity:
    import android.os.Bundle;
    import android.app.Fragment;
    
    public class MainActivity extends Activity {
        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.news_articles);
        }
    }
Note: When you add a fragment to an activity layout by defining the
fragment in the layout XML file, you cannot remove the fragment at runtime.
If you plan to swap your fragments in and out during user interaction, you
must add the fragment to the activity when the activity first starts.

#### Building a Flexible UI ####
When designing your application to support a wide range of screen sizes,
you can reuse your fragments in different layout configurations to optimize
the user experience based on the available screen space.
For example, on a handset device it might be appropriate to display just
one fragment at a time for a single-pane user interface. Conversely, you
may want to set fragments side-by-side on a tablet which has a wider screen
size to display more information to the user.
  --------------------------------------------
  |\\\\\\\\\\\\|/////////////////////////////|
  |\\\\\\\\\\\\|/////////////////////////////|  ----------     ----------
  |\\\\\\\\\\\\|/////////////////////////////|  |\\\\\\\\|     |////////|
  | Fragment A |////////// Fragment B ///////|  |Fragment|---->|Fragment|
  |\\\\\\\\\\\\|/////////////////////////////|  |\\ A \\\|     |// B ///|
  |\\\\\\\\\\\\|/////////////////////////////|  |\\\\\\\\|     |////////|
  --------------------------------------------  ----------     ----------
Figure 1. Two fragments, displayed in different configurations for the same
activity on different screen sizes. On a large screen, both fragments fit
side by side, but on a handset device, only one fragment fits at a time so
the fragments must replace each other as the user navigates.

The FragmentManager class provides methods that allow you to add, remove,
and replace fragments to an activity at runtime in order to create a
dynamic experience.

--> Add a Fragment to an Activity at Runtime
Rather than defining the fragments for an activity in the layout file--with
the <fragment> element--you can add a fragment to the activity during the
activity runtime. This is necessary if you plan to change fragments during
the life of the activity.

To perform a transaction such as add or remove a fragment, you must use the
FragmentManager to create a FragmentTransaction, which provides APIs to
add, remove, replace, and perform other fragment transactions.

If your activity allows fragments to be removed and replaced, you should
add the initial fragment(s) to the activity during the activity's
onCreate() method.

An important rule when dealing with fragments--especially those that you
add at runtime--is that the fragment must have a container View in the
layout in which the fragment's layout will reside.

In order to replace one fragment with another, the activity's layout
includes an empty FrameLayout that acts as the fragment container.
>>>> res/layout/news_articles.xml <<<<
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/fragment_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
这个例子是将FrameLayout做为xml的根节点.实际上,不将FrameLayout做为xml的根
节点也可以,例如写成下面的形式:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <FrameLayout
        android:id="@+id/fragment_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>
只要xml文件有一个<FrameLayout>节点,且该节点包含一个"android:id"属性即可.

Inside your activity, call getFragmentManager() to get a FragmentManager
object. Then call beginTransaction() to create a FragmentTransaction() and
call add() to add a fragment.

You can perform multiple fragment transaction for the activity using the
same FragmentTransaction. When you're ready to make the changes, you must
call commit().
For example, here's how to add a fragment to the previous layout:
import android.os.Bundle;
import android.app.Activity;
import android.app.FragmentTransaction;
import android.app.FragmentManager;

public class MainActivity extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.news_articles);

        // Check that the activity is using the layout version with
        // the fragment_container FrameLayout
        if (findViewById(R.id.fragment_container) != null) {

            // However, if we're being restored from a previous state,
            // then we don't need to do anything and should return or else
            // we could end up with overlapping fragments.
            if (savedInstanceState != null) {
                return;
            }

            // Create a new Fragment to be placed in the activity layout
            HeadlinesFragment firstFragment = new HeadlinesFragment();
            
            // In case this activity was started with special instructions
            // from an Intent, pass the Intent's extras to the fragment as
            // arguments. 此时,HeadlinesFragment类可以调用getArguments()函
            // 数获取这些变量.
            firstFragment.setArguments(getIntent().getExtras());
            
            // Add the fragment to the 'fragment_container' FrameLayout
            FragmentManager fragMgr = getFragmentManager();
            FragmentTransaction fragment = fragMgr.beginTransaction();
            fragment.add(R.id.fragment_container, firstFragment).commit();
        }
    }
}
注意: 上面的fragment执行过一次commit()函数后,如果想再次使用fragment成员来执
行commit()函数,需要用beginTransaction()函数再赋值一次.这两个函数要配套使用:
    fragment = fragMrg.beginTransaction();
    // do something
    fragment.commit();

    fragment = fragMrg.beginTransaction();
    // do another thing
    fragment.commit();      // commit again
如果不这样做,运行时会抛出异常.

Because the fragment has been added to the FrameLayout container at runtime
--instead of defining it in the activity's layout with a <fragment> element
--the activity can remove the fragment and replace it with a differnet one.

--> Replace One Fragment with Another
The procedure to replace a fragment is similar to adding one, but requires
the replace() method instead of add().

Keep in mind that when you perform fragment transactions, such as replace
or remove one, it's often appropriate to allow the user to navigate
backward and "undo" the change. To allow the user to navigate backward
through the fragment transactions, you must call addToBackStack() before
you commit the FragmentTransaction.
Note: When you remove or replace a fragment and add the transaction to the
back statck, the fragment that is removed is stopped (not destroyed). If
the user navigates back to restore the fragment, it restarts. If you do not
add the transaction to the back stack, then the fragment is destroyed when
removed or replaced.

Example of replacing one fragment with another:
// Create fragment and give it an argument specifying the article it
// should show. 之后, ArticleFragment类可以执行getArguments().getInt(
// ARG_POSITION, 0)来获取传入的参数. ARG_POSITION 要定义为 String 类型.
ArticleFragment newFragment = new ArticleFragment();
Bundle args = new Bundle();
args.putInt(ArticleFragment.ARG_POSITION, position);
newFragment.setArguments(args);

FragmentTransaction transaction = getFragmentManager().beginTransaction();

// Replace whatever is in the fragment_container view with this fragment,
// and add the transaction to the back stack so the user can navigate back
transaction.replace(R.id.fragment_container, newFragment);
transaction.addToBackStack(null);

// Commit the transaction
transaction.commit();

The addToBackStack() method takes an optional string parameter that
specifies a unique name for the transaction. The name isn't needed unless
you plan to perform advanced fragment operations using the
FragmentManager.BackStackEntry APIs.

#### Communicating with Other Fragments ####
In order to reuse the Fragment UI components, you should build each as a
completely self-contained, modular component that defines its own layout
and behavior. Once you have defined these reusable Fragments, you can
associate them with an Activity and connect them with the application logic
to realize the overall composite UI.

Often you will want one Fragment to communicate with another, for example
to change the content based on a user event. All Fragment-to-Fragment
communication is done through the associated Activity. Two Fragments should
never communicate directly.

--> Define an Interface
To allow a Fragment to communicate up to its Activity, you can define an
interface in the Fragment class and implement it within the Activity. The
Fragment captures the interface implementation during its onAttach()
lifecycle method and can then call the Interface methods in order to
communicate with the Activity.

Here is an example of Fragment to Activity communication:
public class HeadlinesFragment extends ListFragment {
    OnHeadlineSelectedListener mCallback;

    // Container Activity must implement this interface
    public interface OnHeadlineSelectedListener {
        public void onArticleSelected(int position);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        
        // This makes sure that the container activity has implemented
        // the callback interface. If not, it throws an exception
        try {
            mCallback = (OnHeadlineSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString()
                    + " must implement OnHeadlineSelectedListener");
        }
    }
    
    ...
}

Now the fragment can deliver messages to the activity by calling the
onArticleSelected() method (or other methods in the interface) using the
mCallback instance of the OnHeadlineSelectedListener interface.

For example, the following method in the fragment is called when the user
clicks on a list item. The fragment uses the callback interface to deliver
the event to the parent activity.
@Override
public void onListItemClick(ListView l, View v, int position, long id) {
    // Send the event to the host activity
    mCallback.onArticleSelected(position);
}
注意: 如上所述,这个onListItemClick()函数是在HeadlinesFragment类中定义.

--> Implement the Interface
In order to receive event callbacks from the fragment, the activity that
hosts it must implement the interface defined in the fragment class.
For example, the following activity implements the interface from the
above example.
public static class MainActivity extends Activity
        implements HeadlinesFragment.OnHeadlineSelectedListener {
    ...
    
    public void onArticleSelected(int position) {
        // The user selected the headline of an article from the
        // HeadlinesFragment. Do something here to display that article
    }
}

--> Deliver a Message to a Fragment
The host activity can deliver messages to a fragment by capturing the
Fragment instance with findFragmentById(), then directly call the
fragment's public methods.

For instance, imagine that the activity shown above may contain another
fragment that's used to display the item specified by the data returned in
the above callback method. In this case, the activity can pass the
information received in the callback method to the other fragment that will
display the item:
public static class MainActivity extends Activity
        implements HeadlinesFragment.OnHeadlineSelectedListener {
    ...

    public void onArticleSelected(int position) {
        // The user selected the headline of an article from the
        // HeadlinesFragment. Do something here to display that article

        ArticleFragment articleFrag = (ArticleFragment)
            getFragmentManager().findFragmentById(R.id.article_fragment);

        if (articleFrag != null) {
            // If article frag is available, we're in two-pane layout...

            // Call a method in the ArticleFragment to update its content
            articleFrag.updateArticleView(position);
        } else {
            // Otherwise, we're in the one-pane layout and must swap
            // frags.... Create fragment and give it an argument for the
            // selected article.
            ArticleFragment newFragment = new ArticleFragment();
            Bundle args = new Bundle();
            args.putInt(ArticleFragment.ARG_POSITION, position);
            newFragment.setArguments(args);
        
            FragmentTransaction transaction =
                getFragmentManager().beginTransaction();

            // Replace whatever is in the fragment_container view with this
            // fragment, and add the transaction to the back stack so the
            // user can navigate back
            transaction.replace(R.id.fragment_container, newFragment);
            transaction.addToBackStack(null);

            // Commit the transaction
            transaction.commit();
        }
    }
}

#### Fragment 中调用 findViewById() 函数 ####
findViewById() 函数定义在Activity中,而Fragment类并没有继承自Activity.所以
不能在Fragment类中直接调用findViewById()函数,而是要先执行 getActivity() 函
数获取到 Activity 对象再调用 findViewById() 函数. 例如:
    TextView textview = (TextView) getActivity().findViewById(R.id.text);

#### The Lifecylce of Fragment ####
Fragment也有自己的生命周期,且跟Activity的很相似,只是稍有不同.下面是几个
Activity中没有的新方法:
(1) onAttach(): Fragment 和 Activity 建立关联时调用.在Fragment中,会先调用
    onAttach()函数,再调用onCreate()函数.
(2) onCreateView(): 为 Fragment 加载布局时调用.
(3) onActivityCreated(): 当Activity中的onCreate()方法执行完后调用,但是其
    调用早于Activity中的onStart()函数
(4) onDestroyView(): Fragment中的布局被移除时调用.这个函数会在Activity的
    onStop()函数之后,onDestroy()函数之前调用.
(5) onDetach(): Fragment 和 Activity 解除关联时调用.这个函数会在Fragment的
    onDestroy()函数之后调用.
另外, Fragment 没有实现 Activity 的 onRestart() 函数.

一个 Fragment 和 Activity 的生命周期log 如下:
# 启动 Activity, 该 Activity 会添加一个 Fragment.
D/life-Activity( 5801): 1: >>>>>>>>>> onCreate
D/life-Fragment( 5801): HeadlinesFragment: onAttach
D/life-Fragment( 5801): HeadlinesFragment: onCreate
D/life-Fragment( 5801): HeadlinesFragment: onCreateView
D/life-Fragment( 5801): HeadlinesFragment: onActivityCreated
D/life-Activity( 5801): 2: >>>>>>>>> onStart
D/life-Fragment( 5801): HeadlinesFragment: onStart
D/life-Activity( 5801): 3: >>>>>>>>> onResume
D/life-Fragment( 5801): HeadlinesFragment: onResume
# 点击 HOME 键,返回主界面
D/life-Fragment( 5801): HeadlinesFragment: onPause
D/life-Activity( 5801): 4: <<<<<<<<< onPause
D/life-Fragment( 5801): HeadlinesFragment: onStop
D/life-Activity( 5801): 5: <<<<<<<<< onStop
# 通过"最近任务列表"界面,返回 Activity 应用
D/life-Activity( 5801): 7: >>>>>>>>> onRestart
D/life-Activity( 5801): 2: >>>>>>>>> onStart
D/life-Fragment( 5801): HeadlinesFragment: onStart
D/life-Activity( 5801): 3: >>>>>>>>> onResume
D/life-Fragment( 5801): HeadlinesFragment: onResume
# 点击 BACK 键退出该 Activity 应用.
D/life-Fragment( 5801): HeadlinesFragment: onPause
D/life-Activity( 5801): 4: <<<<<<<<< onPause
D/life-Fragment( 5801): HeadlinesFragment: onStop
D/life-Activity( 5801): 5: <<<<<<<<< onStop
D/life-Fragment( 5801): HeadlinesFragment: onDestroyView
D/life-Fragment( 5801): HeadlinesFragment: onDestroy
D/life-Fragment( 5801): HeadlinesFragment: onDetach
D/life-Activity( 5801): 6: <<<<<<<<< onDestroy
可以看到,在启动时,会先执行Activity的函数,再执行Fragment的函数,在停止时,会
先执行Fragment的函数,再执行Activity的函数.在Fragment中,调用最早的函数是
onAttach()函数,调用最晚的函数是onDetach()函数.

Section: 保存数据到本地
#### Saving Data ####
Most Android apps need to save data, even if only to save information about
the app state during onPause() so the user's progress is not lost. Most
non-trivial apps also need to save user settings, and some apps must manage
large amounts of information in files and databases.

#### Saving Key-Value Sets ####
If you have a relatively small collection of key-values that you'd like to
save, you should use the SharedPreferences APIs. A SharedPreferences object
points to a file containing key-value pairs and provides simple methods to
read and write them. Each SharedPreferences file is managed by the
framework and can be private or shared. 可见, SharedPreferences 对象关联到
实际的文件,即使关机重启,所保存的值也还在文件里面.

使用SharedPreferences时,需要添加"import android.content.SharedPreferences"
来引入这个包.

Note: The SharedPreferences APIs are only for reading and writing key-value
pairs and you should not confuse them with the Preference APIs, which help
you build a user interface for your app settings (although they use
SharedPreferences as their implementation to save the app settings).

--> Get a Handle to a SharedPreferences
You can create a new shared preference file or access an existing one by
calling one of two methods:
(1) getSharedPreferences()--Use this if you need multiple shared preference
file identified by name, which you specify with the first parameter. You
can call this from any Context in your app. Activity间接继承自Context,可以
直接在Activity类中调用 getSharedPreferences() 函数.
(2) getPreferences()--Use this from an Activity if you need to use only one
shared preference file for the activity. Because this retrieves a default
shared preference file that belongs to the activity, you don't need to
supply a name.

For example, the following code is executed inside a Activity. It accesses
the shared preferences file that's identified by the resource string
"R.string.preference_file_key" and opens it using the private mode so the
file is accessible by only your app.
    SharedPreferences sharedPref = getSharedPreferences(
        getString(R.string.preference_file_key), Context.MODE_PRIVATE);
When naming your shared preference files, you should use a name that's
uniquely identifiable to your app, such as "com.example.myapp.FILE_KEY".
使用这种方法得到的SharedPreferences会关联到一个实际的文件.假设当前Activity
所在的包名是"com.example.mysavedata",则在机器上,这个文件的所在目录是:
    "/data/data/com.example.mysavedata/shared_prefs"
而该文件的文件名会是: "com.example.mysavedata.FILE_KEY.xml". 即,这个文件名
由"包名.第一个参数.xml"组成.这里的"第一个参数"指的是getSharedPreferences()
函数的第一个参数.显然,这是一个XML文件,里面内容类似于:
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
    <int name="saved_high_score" value="88" />
</map>
即,这里面保存了一个键名为"saved_high_score",键值为"88"的键值对.

Alternatively, if you need just one shared preference file for your
activity, you can use the getPreferences() method:
    SharedPreferences sharedPref = getPreferences(Context.MODE_PRIVATE);
用这个函数得到的SharedPreferences也关联到一个实际的文件,以上面的包名为例,则
这个文件所在路径也是: "/data/data/com.example.mysavedata/shared_prefs".
不过,它的文件名会是 "MainActivity.xml". 这个"MainActivity"是当前Activity的
名字.即getPreferences()函数关联到的文件名为 "Activity名.xml". 该文件里面的
内容和上面 "com.example.mysavedata.FILE_KEY.xml" 文件的内容类似.

Caution: If you create a shared preferences file with MODE_WORLD_READABLE
or MODE_WORLD_WRITEABLE, then any other apps that know the file identifier
can access your data. 这两个常量在API level 17中已经标记为废弃,尽量不要用.

--> Write to Shared Preferences
To write to a shared preferences file, create a SharedPreferences.Editor
by calling edit() on your SharedPreferences.

Pass the keys and values you want to write with methods such as putInt()
and putString(). Then call commit() to save the changes. For example:
    SharedPreferences sharedPref = getPreferences(Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPref.edit();
    editor.putInt(getString(R.string.saved_high_score), newHighScore);
    editor.commit();
getPreferences()函数关联到"shared_prefs/MainActivity.xml"文件.putInt()函数
会在该XML文件中添加这样一项:
    <int name="saved_high_score" value="88" />
如果执行的是 editor.putString("saved_name", "John"),则会添加这样一项:
    <string name="saved_name">John</string>
在调用commit()函数之前,可以调用多个putInt(), putString()函数来写入多个值.

SharedPreferences.Editor中,还有putLong(), putBoolean()等函数可以其他类型的
值.另外可以调用 "remove(String key)" 函数可以删除所对应XML文件的某项,也可
以调用 "clean()" 清除所对应XML文件中的所有项.

--> Read from Shared Preferences
To retrieve values from a shared preferences file, call methods such as
getInt() and getString(), providing the key for the value you want, and
optionally a default value to return if the key isn't present. For example:
 SharedPreferences sharedPref = getPreferences(Context.MODE_PRIVATE);
 int highScore = sharedPref.getInt(getString(R.string.saved_high_score), 0)
实际上,SharedPreferences类的getInt()函数必须提供一个默认值,而不是可选的,否
则编译报错. SharedPreferences 类只定义了一个 getInt() 函数,其原型如下:
    int getInt(String key, int defValue);
在SharedPreferences中,并不存在一个原型为"int getInt(String key)"的重载函数.

#### Saving Files ####
Android uses a file system that's similar to disk-based file systems on
other platforms. The following describes how to work with the Android file
system to read and write files with the File APIs.
A File object is suited to reading or writing large amounts of data in
start-to-finish order without skipping around. For example, it's good for
image files or anything exchanged over a network.

--> Choose Internal or External Storage
All Android devices have two file storage areas: "internal" and "external"
storage. These names come from the early days of Android, when most devices
offered built-in non-volatile memory (internal storage), plus a removable
storage medium such as a micro SD card (external storage). Some devices
divide the permanent storage space into "internal" and "external"
partitions, so even without a removable storage medium, there are always
two storage spaces and the API behavior is the same whether the external
storage is removable or not. The following lists summarize the facts about
each storage space.
> Internal storage: (1) It's always available. (2) Files saved here are
accessible by only your app by default. (3) When the user uninstalls your
app, the system removes all your app's files from internal storage. (4)
Internal storage is best when you want to be sure that neither the user nor
other apps can access your files.
> External storage: (1) It's not always available, because the user can
mount the external storage as USB storage and in some cases remove it from
the device. (2) It's world-readable, so files saved here may be read
outside of your control. (3) When the user uninstalls your app, the system
removes your app's files from here only if you save them in the directory
from getExternalFilesDir(). (4) External storage is the best place for
files that don't require access restrictions and for files that you want to
share with other apps or allow the user to access with a computer.

Tip: Although apps are installed onto the internal storage by default, you
can specify the "android:installLocation" attribute in your manifest so
your app may be installed on external storage. Users appreciate this option
when the APK size is very large and then have an external storage space
that's larger than the internal storage.

--> Obtain Permissions for External Storage
To write to the external storage, you must request the
WRITE_EXTERNAL_STORAGE permission in your manifest:
<manifest ...>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 ...
</manifest>
Caution: Currently, all apps have the ability to read the external storage
without a special permission. However, this will change in a future release.
If your app needs to read the external storage (but not write to it), then
you will need to declare the READ_EXTERNAL_STORAGE permission. To ensure
that your app continues to work as expected, you should declare this
permission now, before the change takes effect.
<manifest ...>
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
...
</manifest>
However, if your app uses the WRITE_EXTERNAL_STORAGE permission, then it
implicitly has permission to read the external storage as well.

You don't need any permissions to save files on the internal storage. Your
application always has permission to read and write files in its internal
storage directory.

--> Save a File on Internal Storage
When saving a file to internal storage, you can acquire the appropriate
directory as a File by calling one of two methods:
getFilesDir():
    Returns a File representing an internal directory for your app.
getCacheDir();
    Returns a File representing an internal directory for your app's
    temporary cache files. Be sure to delete each file once it is no longer
    needed and implement a reasonable size limit for the amount of memory
    you use at any given time, such as 1MB. If the system begins running
    low on storage, it may delete your cache files without warning.
以包名"com.example.mysavedata"为例,上面两个函数所返回的目录路径分别如下:
    getFilesDir() = /data/data/com.example.mysavedata/files
    getCacheDir() = /data/data/com.example.mysavedata/cache

To create a new file in one of these directories, you can use the File()
constructor, passing the File provided by one of the above methods that
specifies your internal storage directory. For example:
    File file = new File(context.getFilesDir(), filename);
Alternatively, you can call openFileOutput() to get a FileOutputStream that
writes to a file in your internal directory. For example, here's how to
write some text to a file (注意添加import java.io.FileOutputStream;语句):
    String filename = "myfile";
    String string = "Hello world!";
    FileOutputStream outputStream;
    
    try {
      outputStream = openFileOutput(filename, Context.MODE_PRIVATE);
      outputStream.write(string.getBytes());
      outputStream.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
openFileOutput()函数会在internal storage的目录下新建一个文件,文件名就是该函
数的第一个参数.例如: "/data/data/com.example.mysavedata/files/myfile".

Or, if you need to cache some files, you should instead use
createTempFile(). 举例如下 (注意添加import java.io.File来引入File包):
    File file;
    try {
        file = File.createTempFile("mycachefile", null, getCacheDir());
    } catch (Exception e) {
        e.printStackTrace();
    }
这部分代码会在"/data/data/com.example.mysavedata/cache/"目录下创建一个缓存
文件,例如"mycachefile1049843177.tmp". 可以看到,该文件名的组成方式为:
    "createTempFile()函数的第一个参数" + "随机数" + ".tmp"
再次执行这部分代码,所创建的缓存文件名可能就是"mycachefile1450557224.tmp".
当然,也有可能是其他文件名.这里主要想说明,所创建的缓存文件名不会重复.

Note: Your app's internal storage directory is specified by your app's
package name in a special location of the Android file system. Technically,
another app can read your internal files if you set the file mode to be
readable. However, the other app would also need to know your app package
name and file names. Other apps cannot browse your internal directories and
do not have read or write access unless you explicitly set the files to be
readable or writable. So as long as you use MODE_PRIVATE for your files on
the internal storage, they are never accessible to other apps.

--> Save a File on External Storage
Because the external storage may be unavailable--such as when the user has
mounted the storage to a PC or has removed the SD card that provides the
external storage--you should always verify that the volume is available
before accessing it. You can query the external storage state by calling
getExternalStorageState(). If the returned state is equal to MEDIA_MOUNTED,
then you can read and write your files. For example, the following methods
are useful to determine the storage availability:
注意: 添加 "import android.os.Environment;" 语句来引入 Environment 包.
    /* Checks if external storage is available for read and write */
    public boolean isExternalStorageWritable() {
        String state = Environment.getExternalStorageState();
        if (Environment.MEDIA_MOUNTED.equals(state)) {
            return true;
        }
        return false;
    }
    
    /* Checks if external storage is available to at least read */
    public boolean isExternalStorageReadable() {
        String state = Environment.getExternalStorageState();
        if (Environment.MEDIA_MOUNTED.equals(state) ||
            Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
            return true;
        }
        return false;
    }
Although the external storage is modifiable by the user and other apps,
there are two categories of files you might save here:
> Public files
    Files that should be freely available to other apps and to the user.
    When the user uninstalls your app, these files should remain available
    to the user.
    For example, photos captured by your app or other downloaded files.
> Private files
    Files that rightfully belong to your app and should be deleted when the
    user uninstalls your app. Although these files are technically
    accessible by the user and other apps because they are on the external
    storage, they are files that realistically don't provide value to the
    user outside your app. When the user uninstalls your app, the system
    deletes all files in your app's external private directory.
    For example, additional resources downloaded by your app or temporary
    media files.

If you want to save public files on the external storage, use the
getExternalStoragePublicDirectory() method to get a File representing the
appropriate directory on the external storage. The method takes an argument
specifying the type of file you want to save so that they can be logically
organized with other public files, such as DIRECTORY_MUSIC or 
DIRECTORY_PICTURES. For example (添加import android.so.Environment;语句):
    public File getAlbumStorageDir(String albumName) {
        // Get the directory for the user's public pictures directory. 
        File file = new File(Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_PICTURES), albumName);
        if (!file.mkdirs()) {
            Log.e(LOG_TAG, "Directory not created");
        }
        return file;
    }
调试发现,getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)
语句返回的目录路径是"/mnt/sdcard/Pictures".这个路径中的"/mnt/sdcard/"随机器
不同可能有所不同.主要是在于"Pictures"这个目录名上.
执行 "getAlbumStorageDir(myalbum);" 语句,将会在"/mnt/sdcard/Pictures/"目录
下新建一个"myalbum"子目录. 解释如下:
(1) getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)语句
会返回 "/mnt/sdcard/Pictures".
(2) File(String dirPath, String name)构造函数会使用指定的目录名和文件名来
构造出一个新的File对象.在目录名和文件名中间会放一个路径分隔符('/').这个语句
只是得到一个文件名,但是该文件可能还没有被创建出来.
(3) file.mkdirs() 语句会使用该file对象的文件名来创建一个目录,如果该文件的父
目录不存在,则会先创建其父目录,再创建该文件.对该函数以及mkdir()函数描述如下:
mkdir(): Creates the directory named by this file, assuming its parents
         exist. Use mkdirs() if you also want to create missing parents.
mkdirs(): Creates the directory named by this file, creating missing parent
          directories if necessary. Use mkdir() if you don't want to create
          missing parents.
如果所要创建的目录已经存在,这两个函数都会报错.

If you want to save files that are private to your app, you can acquire the
appropriate directory by calling getExternalFilesDir() and passing it a
name indicating the type of directory you'd like. Each directory created
this way is added to a parent directory that encapsulates all your app's
external storage files, which the system deletes when the user uninstalls
your app. For example, here's a method you can use to create a directory
for an invididual photo album:
    public File getAlbumStorageDir_t(Context context, String albumName) {
        // Get the directory for the app's private pictures directory. 
        File file = new File(context.getExternalFilesDir(
                Environment.DIRECTORY_PICTURES), albumName);
        if (!file.mkdirs()) {
            Log.e(LOG_TAG, "Directory not created");
        }
        return file;
    }
调试发现,getExternalFilesDir(Environment.DIRECTORY_PICTURES)返回的目录路径
是"/mnt/sdcard/Android/data/com.example.mysavedata/files/Pictures".这里的
"com.example.mysavedata"是当前Activity的包名.这个getAlbumStorageDir_t()函数
会在该目录下创建一个子目录,其目录名为albumName变量的值.例如:
  "/mnt/sdcard/Android/data/com.example.mysavedata/files/Pictures/myalbum"

If none of the pre-defined sub-directory names suit your files, you can
instead call getExternalFilesDir() and pass null. This return the root
directory for your app's private directory on the external storage.
该根目录路径是:"/mnt/sdcard/Android/data/com.example.mysavedata/files".

Remember that getExternalFilesDir() creates a directory inside a directory
that is deleted when the user uninstalls your app. If the files you're
saving should remain available after the user uninstalls your app--such as
when your app is a camera and the user will want to keep the photos--you
should instead use getExternalStoragePublicDirectory().

Regardless of whether you use getExternalStoragePublicDirectory() for files
that are shared or getExternalFilesDir() for files that are private to
your app, it's important that you use directory names provided by API
constants like DIRECTORY_PICTURES. These directory names ensure that the
files are treated properly by the system. For instance, files saved in
DIRECTORY_RINGTONES are categorized by the system media scanner as
ringtones instead of music.

--> Query Free Space
If you know ahead of time how much data you're saving, you can find out
whether sufficient space is available without causing an IOException by
calling getFreeSpace() or getTotalSpace(). These methods provide the
current available space and the total space in the storage volume,
respectively. This information is also useful to avoid filling the storage
volume above a certain threshold. 注意: getFreeSpace() 和 getTotalSpace()
函数都属于 File 类,需要通过 File 类的对象来调用. 例如:
    try {
        String albumName = "testdir";
        File file = new File(context.getExternalFilesDir(
                Environment.DIRECTORY_PICTURES), albumName);
        // 如果该 file 对应的文件不存在, getFreeSpace() 和 getTotalSpace()
        // 会返回0.所以下面调用mkdirs()函数创建出一个新目录,以便能查询到正
        // 确的空量.即,这两个查询容量的函数要通过已经存在的文件来进行查询.
        if (!file.mkdirs()) {
            Log.e(LOG_TAG, "Directory not created");
        }

        // getFreeSpace() 和 getTotalSpace() 函数都返回 long 类型,如果下面
        // 的freeSpace和totalSpace声明为int型,编译会提示"可能损失精度".
        long freeSpace = file.getFreeSpace();
        long totalSpace = file.getTotalSpace();
    } catch (Exception e) {
        e.printStackTrace();
    }
> long getFreeSpace(): Returns the number of free bytes on the partition
  containing this path. Returns 0 if this path does not exist. Note that
  this is likely to be an optimistic over-estimate and should not be taken
  as a guarantee your application can actually write this many bytes.
> long getTotalSpace(): Returns the total size in bytes of the partition
  containing this path. Returns 0 if this path does not exist.

However, the system does not guarantee that you can write as many bytes as
are indicated by getFreeSpace(). If the number returned is a few MB more
than the size of the data you want to save, or if the file system is less
than 90% full, then it's probably safe to proceed. Otherwise, you probably
shouldn't write to storage.
Note: You aren't required to check the amount of available space before you
save your file. You can instead try writing the file right away, then catch
an IOException if one occurs. You may need to do this if you don't know
exactly how much space you need. For example, if you change the file's
encoding before you save it by converting a PNG image to JPEG, you won't
know the file's size beforehand.

--> Delete a File
You should always delete files that you no longer need. The most
straightforward way to delete a file is to have the opened file reference
call delete() on itself.
    myFile.delete();    // myFile 是 File 类的对象
If the file is saved on internal storage, you can also ask the Context to
locate and delete a file by calling deleteFile():
    myContext.deleteFile(fileName);
Note: When the user uninstalls your app, the Android system deletes the
following:
> All files you saved on internal storage
> All files you saved on external storage using getExternalFilesDir().

However, you should manually delete all cached files created with
getCacheDir() on a regular basis and also regularly delete other files
you no longer need.

#### Saving Data in SQL Databases ####
Saving data to a database is ideal for repeating or structured data, such
as contact information. The APIs you'll need to use a database on Android
are available in the "android.database.sqlite" package.

--> Define a Schema and Contract
One of the main principles of SQL databases is the schema: a formal
declaration of how the database is organized. The schema is reflected in
the SQL statements that you use to create your database. You may find it
helpful to create a companion class, known as a contract class, which
explicitly specifies the layout of your schema in a systematic and
self-documenting way.

A contract class is a container for constants that define names for URIs,
tables, and columns. The contract class allows you to use the same
constants across all the other classes in the same package. This lets you
change a column name in one place and have it propagate throughout your
code. A good way to organize a contract class is to put definitions that
are global to your whole database in the root level of the class. Then
create an inner class for each table that enumerates its columns.
Note: By implementing the BaseColumns interface, your inner class can
inherit a primary key field called _ID that some Android classes such as
cursor adaptors will expect it to have. It's not required, but this can
help your database work harmoniously with the Android framework.

For example, this snippet defines the table name and column names for a
single table:
    public final class FeedReaderContract {
        // To prevent someone from accidentally instantiating the contract
        // class, give it an empty constructor.
        public FeedReaderContract() {}
    
        /* Inner class that defines the table contents */
        public static abstract class FeedEntry implements BaseColumns {
            public static final String TABLE_NAME = "entry";
            public static final String COLUMN_NAME_ENTRY_ID = "entryid";
            public static final String COLUMN_NAME_TITLE = "title";
            public static final String COLUMN_NAME_SUBTITLE = "subtitle";
            ...
        }
    }
其实,主要就是把各个表项的值统一放到一个类里面,方便多次复用.

--> Create a Database Using a SQL Helper
Once you have defined how your database looks, you should implement methods
that create and maintain the database and tables. Here are some typical
statements that create and delete a table:
    private static final String TEXT_TYPE = " TEXT";
    private static final String COMMA_SEP = ",";
    private static final String SQL_CREATE_ENTRIES =
        "CREATE TABLE " + FeedEntry.TABLE_NAME + " (" +
        FeedEntry._ID + " INTEGER PRIMARY KEY," +
        FeedEntry.COLUMN_NAME_ENTRY_ID + TEXT_TYPE + COMMA_SEP +
        FeedEntry.COLUMN_NAME_TITLE + TEXT_TYPE + COMMA_SEP +
        ... // Any other options for the CREATE command
        " )";
    
    private static final String SQL_DELETE_ENTRIES =
        "DROP TABLE IF EXISTS " + FeedEntry.TABLE_NAME;

实际调试的时候,将这部分内容放到了下面的FeedReaderDbHelper类里面,所以在
FeedReaderDbHelper类的源文件里面,需要添加 "import com.example.mysavedata.
FeedReaderContract.FeedEntry;" 语句来引入FeedEntry包.

Just like files that you save on the device's internal storage, Android
stores your database in private disk space that's associated application.
Your data is secure, because by default this area is not accessible to
other applications. 假设当前Activity的包名是"com.example.mysavedata",则它
的数据库会存放在 "/data/data/com.example.mysavedata/databases" 目录下.

A useful set of APIs is available in the SQLiteOpenHelper class. When you
use this class to obtain references to your database, the system performs
the potentially long-running operations of creating and updating the
database only when needed and not during app startup. All you need to do
is call getWritableDatabase() or getReadableDatabase().
Note: Because they can be long-running, be sure that you call
getWritableDatabase() or getReadableDatabase() in a background thread, such
as with AsyncTask or IntentService.

To use SQLiteOpenHelper, create a subclass that overrides the onCreate(),
onUpgrade() and onOpen() callback methods. You may also want to implement
onDowngrade(), but it's not required.

For example, here's an implementation of SQLiteOpenHelper that uses some of
the commands shown above:
public class FeedReaderDbHelper extends SQLiteOpenHelper {
    // If you change the database schema, you must increment the database
    // version.
    public static final int DATABASE_VERSION = 1;
    public static final String DATABASE_NAME = "FeedReader.db";

    public FeedReaderDbHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(SQL_CREATE_ENTRIES);
    }
    public void onUpgrade(SQLiteDatabase db, int oldVer, int newVer) {
        // This database is only a cache for online data, so its upgrade
        // policy is to simply to discard the data and start over
        db.execSQL(SQL_DELETE_ENTRIES);
        onCreate(db);
    }
    public void onDowngrade(SQLiteDatabase db, int oldVer, int newVer) {
        onUpgrade(db, oldVer, newVer);
    }
}

To access your database, instantiate your subclass of SQLiteOpenHelper:
    FeedReaderDbHelper mDbHelper = new FeedReaderDbHelper(getContext());
执行这条语句,将会创建一个名为 "FeedReader.db" 的数据库,其完整路径是:
    "/data/data/com.example.mysavedata/databases/FeedReader.db"
如果FeedReader.db数据库不存在,则在执行FeedReaderDbHelper类的构造函数后,系统
会回调其onCreate()函数,从而执行 "db.execSQL(SQL_CREATE_ENTRIES)" 语句,通过
SQL命令创建一个数据库.经过验证发现,当FeedReader.db已经存在时,再次调用
FeedReaderDbHelper类的构造函数,不会回调其 onCreate() 函数.

--> Put Information into a Database
Insert data into the database by passing a ContentValues object to the
insert() method:
    // Gets the data repository in write mode
    SQLiteDatabase db = mDbHelper.getWritableDatabase();
    
    // Create a new map of values, where column names are the keys
    ContentValues values = new ContentValues();
    values.put(FeedEntry.COLUMN_NAME_ENTRY_ID, id);
    values.put(FeedEntry.COLUMN_NAME_TITLE, title);
    values.put(FeedEntry.COLUMN_NAME_CONTENT, content);
    
    // Insert the new row, returning the primary key value of the new row
    long newRowId;
    newRowId = db.insert(
             FeedEntry.TABLE_NAME,
             FeedEntry.COLUMN_NAME_NULLABLE,
             values);
The first argument for insert() is simply the table name. The second
argument provides the name of a conlumn in which the framework can insert
NULL in the event that the ContentValues is empty (if you instead set this
to "null", then the framework will not insert a row when there are no
values. 对该 insert() 函数进一步描述如下:
  long insert(String table, String nullColumnHack, ContentValues values)
> Convenience method for inserting a row into the database.
> Parameters
    table: the table to insert the row into
    nullColumnHack: optional; may be null. SQL doesn't allow inserting a
      completely empty row without naming at least one column name. If your
      provided values is empty, no column names are known and an empty row
      can't be inserted. If not set to null, the nullColumnHack parameter
      provides the name of nullable column name to explicitly insert a NULL
      into in the case where your values is empty. 即,当insert()函数的第三
      个参数为空,则第二个参数必须指定表的某个字段名,否则不符合SQL语句规范.
      假设表A中有两个字段,title, id.当insert()的时候,如果传递给它的第三个参
      数为空,那么语句就该写成insert(A, "title", null).第二个参数可以写成
      "title"或"id",以"title"为例.则转换为SQL就是insert into A(title)
      values(null).此时若insert()函数的第二个参数也是空,则转换后的SQL语句为
      insert into A() values(null),这个语句是有问题的,不符合SQL规范.
    values: this map contains the initial column values for the row. The
      keys should be the column names and the values the column values.
> Returns: the row ID of the newly inserted row, or -1 if an error occurred

在这个例子中,简单地将上面的 FeedEntry.COLUMN_NAME_NULLABLE 赋值为null即可:
    public static final String COLUMN_NAME_NULLABLE = null;

--> Read Information from a Database
To read from a database, use the query() method, passing it your selection
criteria and desired columns. The method combines elements of insert() and
update(), except the column list defines the data you want to fetch, rather
than the data to insert. The results of the query are returned to you in a
Cursor object. 注意添加"import android.database.Cursor;"语句来引入Cursor包.
    SQLiteDatabase db = mDbHelper.getReadableDatabase();
    
    // Define a projection that specifies which columns from the database
    // you will actually use after this query.
    String[] projection = {
        FeedEntry._ID,
        FeedEntry.COLUMN_NAME_TITLE,
    };
    
    // How you want the results sorted in the resulting Cursor
    // 注意,在"DESC"前面有一个空格.
    String sortOrder = FeedEntry._ID + " DESC";
    String selection = FeedEntry.COLUMN_NAME_TITLE + " = ?";
    String[] selectionArgs = { "Hello" };
    
    Cursor c = db.query(
        FeedEntry.TABLE_NAME,  // The table to query
        projection,            // The columns to return
        selection,             // The columns for the WHERE clause
        selectionArgs,         // The values for the WHERE clause
        null,                  // don't group the rows
        null,                  // don't filter by row groups
        sortOrder              // The sort order
        );
对上面的 query() 函数描述如下:
Cursor query(String table, String[] columns, String selection,
  String[] selectionArgs, String groupBy, String having, String orderBy);
> Query the given table, returning a Cursor over the result set.
> Parameters
    table: The table name to compile the query against.
    columns: A list of which columns to return. Passing null will return
      all columns, which is discouraged to prevent reading data from
      storage that isn't going to be used.
    selection: A filter declaring which rows to return, formatted as an
      SQL WHERE clause (excluding the WHERE itself). Passing null will
      return all rows for the given table.
    selectionArgs: You may include ?s in selection, which will be replaced
      by the values from selectionArgs, in order that they appear in the
      selection. The values will be bound as Strings.
    groupBy: A filter declaring how to group rows, formatted as an SQL
      GROUP BY clause (excluding the GROUP BY itself). Passing null will
      cause the rows to not be grouped.
    having: A filter declare which row groups to include in the cursor, if
      row grouping is being used, formatted as an SQL HAVING clause
      (excluding the HAVING itself). Passing null will cause all row groups
      to be included, and is required when row grouping is not being used.
    orderBy: How to order the rows, formatted as an SQL ORDER BY clause
      (excluding the ORDER BY itself). Passing null will use the default
      sort order, which may be unordered.
> Return: A Cursor object, which is positioned before the first entry.
所以,上面的query()语句中,selection和selectionArgs参数组合之后,得到一个WHERE
语句为"WHERE title = Hello". selection字符串中的问号('?')起到占位符的作用,
这个问号会用selectionArgs[]数组中的元素值来代替,得到一个新的字符串.

To look at a row in the cursor, use one of the Cursor move methods, which
you must always call before you begin reading values. Generally, you should
start by calling moveToFirst(), which places the "read position" on the
first entry in the results. For each row, you can read a column's value by
calling one of the Cursor get methods, such as getString() or getLong().
For each of the get methods, you must pass the index position of the column
you desire, which you can get by calling getColumnIndex() or
getColumnIndexOrThrow(). For example:
    while (cursor.moveToFirst()) {
        long itemId = cursor.getLong(
                cursor.getColumnIndexOrThrow(FeedEntry._ID));
    }
下面对 moveToFirst() 函数描述如下:
    boolean moveToFirst();
> Move the cursor to the first row. This method will return false if the
  cursor is empty.
> Return: whether the move succeeded.
所以,为了避免触发异常,要先确保moveToFirst()函数返回为真,再去读取数据.

--> Delete Information from a Database
To delete rows from a table, you need to provide selection criteria that
identify the rows. The database API provides a mechanism for creating
selection criteria that protects against SQL injection. The mechanism
divides the selection specification into a selection clause and selection
arguments. The clause defines the columns to look at, and also allows you
to combine column tests. The arguments are values to test against that are
bound into the clause. Because the result isn't handled the same as a
regular SQL statement, it is immune to SQL injection.
    // Define 'where' part of query.
    String selection = FeedEntry.COLUMN_NAME_ENTRY_ID + " LIKE ?";
    // Specify arguments in placeholder order.
    int rowId = 1;
    String[] selectionArgs = { String.valueOf(rowId) };
    // Issue SQL statement.
    db.delete(table_name, selection, selectionArgs);

--> Update a Database
When you need to modify a subset of your database values, use the update()
method.
Updating the table combines the content values syntax of insert() with the
where syntax of delete().
    SQLiteDatabase db = mDbHelper.getReadableDatabase();
    
    // New value for one column
    ContentValues values = new ContentValues();
    values.put(FeedEntry.COLUMN_NAME_TITLE, title);
    
    // Which row to update, based on the ID
    String selection = FeedEntry.COLUMN_NAME_ENTRY_ID + " LIKE ?";
    int rowId = 1;
    String[] selectionArgs = { String.valueOf(rowId) };
    
    int count = db.update(
        FeedReaderDbHelper.FeedEntry.TABLE_NAME,
        values,
        selection,
        selectionArgs);

在SQLite数据库中,LIKE操作符可以用通配符来进行模糊匹配.其中,下划线'_'匹配
一个字符,百分号'%'匹配多个字符. LIKE 在匹配字符串不区分大小写. 例如:
> LIKE 'Mc%': 匹配以Mc开头的所有字符串. 如McBadden.
> LIKE '%ger': 匹配以inger结尾的所有字符串. 如Rger, Sger.
> LIKE '_her': 匹配以her结尾的总共四个字母的名称. 如Cher,不匹配Cnher.
> LIKE '[CK]ars[eo]n': 将匹配这些字符串: Carsen, Karsen, Carson, Karson.
> LIKE '[M-Z]in': 匹配以in结尾,以从M到Z之间的单个字母开头的名称. 如Rin.
> LIKE 'M[^c]%': 匹配以M开头,并且第二个字母不是c的所有名称. 如Mafat.

Section: 操作摄像头(拍照,录像等)
#### Taking Photos Simply ####
This lesson explains how to capture photos using an existing camera
application. 即,往Android自带的摄像机程序发送 Intent,让它来处理拍照请求.

--> Request Camera Permission
To access the device camera, you must declare the CAMERA permission in your
Android Manifest. Also be sure to include the <uses-feature> manifest
element to declare camera features used by your application. For example,
if you use the camera and auto-focus feature, your Manifest should include
the following:
     <uses-permission android:name="android.permission.CAMERA" />
     <uses-feature android:name="android.hardware.camera" />
     <uses-feature android:name="android.hardware.camera.autofocus" />
另外,如果要保存所拍的照片到外部存储(SD卡)上,还需要申请写外部存储的权限,
WRITE_EXTERNAL_STORAGE 写权限隐式包含了 READ_EXTERNAL_STORAGE 读权限.
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

If an essential function of your application is taking pictures, then
restrict its visibility on Google Play to devices that have a camera. To
advertise that your application depends on having a camera, put a <uses-
feature> tag in your manifest file, with the "android:required" attribute:
    <uses-feature android:name="android.hardware.camera"
        android:required="true" />
If your application uses, but does not require a camera in order to
function, instead set "android:required" to false, In doing so, Google Play
will allow devices withoug a camera to download you application. It's then
your responsibility to check for the availability of the camera at runtime
by calling hasSystemFeature(PackageManager.FEATURE_CAMERA). If a camera is
not available, you should then disable your camera features.
即,对于一个拍照应用而言,所安装的机器上要有摄像头才能正常工作.当发布应用到
应用商店后,如果只想让拥有摄像头的机器才能查找到自己的应用,就将上面的camera
feature中,将"android:required"设成true.如果想让没有摄像头的机器也能查找到
自己的应用,就将"android:required"设成false.此时,代码要调用hasSystemFeature()
函数来判断机器是否支持camera feature,如果不支持,不能进行摄像头的相关操作.

--> Take a Photo with the Camera App
The Android way of delegating actions to other applications is to invoke an
Intent that describes what you want done. This process involves three
pieces: The Intent itself, a call to start the external Activity, and some
code to handle the image data when focus returns to your activity.
Here's a function that invokes an intent to capture a photo.
    import android.content.Intent;
    import android.app.Activity;         // for getPackageManager()
    import android.provider.MediaStore;

    static final int REQUEST_TAKE_PHOTO = 1;
    private void dispathTakePictureIntent() {
        Intent photoIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        if (photoIntent.resolveActivity(getPackageManager()) != null) {
            startActivityForResult(photoIntent, REQUEST_TAKE_PHOTO);
        }
    }
Notice that the startActivityForResult() method is protected by a condition
that calls resolveActivity(), which returns the first activity component
that can handle the intent. Performing this check is important because if
you call startActivityForResult() using an intent that no app can handle,
your app will crash. So as long as the result is not null, it's safe to
use the intent.
只执行这部分代码时,可以启用摄像机程序,并拍一张照片,但是这张照片不会被保存.
如果想查看或者保存这张照片,还需要添加后面的代码.

--> Get the Thumbnail
The Android Camera application encodes the photo in the return Intent
delivered to onActivityResult() as a small Bitmap in the extras, under the
key "data". The following code retrieves this image and displays it in an
ImageView.
    import android.os.Bundle;
    import android.widget.ImageView;
    import android.graphics.Bitmap;

    private ImageView mImageView;  // 注意对mImageView变量进行初始化
    @Override
    protected void onActivityResult(int request, int result, Intent data) {
        if (request == REQUEST_TAKE_PHOTO && result == RESULT_OK) {
            Bundle extras = data.getExtras();
            Bitmap imageBitmap = (Bitmap) extras.get("data");
            mImageView.setImageBitmap(imageBitmap);
        }
    }
This thumbnail image from "data" might be good for an icon.
添加这部分代码后,可以查看启动摄像机程序时所拍的照片,但图片比较小,不清晰.

--> Save the Full-size Photo
The Android Camera application saves a full-size photo if you give it a
file to save into. You must provide a fully qualified file name where the
camera app should save the photo.
Generally, any photos that the user captures with the device camera should
be saved on the device in the public external storage so they are accessible
by all apps. The proper directory for shared photos is provided by
getExternalStoragePublicDirectory(), with the DIRECTORY_PICTURES argument.
Because the directory provided by this method is shared among all apps,
reading and writing to it requires the READ_EXTERNAL_STORAGE and
WRITE_EXTERNAL_STORAGE permissions, respectively. The write permission
implicitly allows reading, so if you need to write to the external storage,
then you need to request only one permission:
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

However, if you'd like the photos to remain private to your app only, you
can instead use the directory provided by getExternalFilesDir(). On Android
4.3 and lower, writing to this directory also requires the
WRITE_EXTERNAL_STORAGE permission. Beginning with Android 4.4, the
permission is no longer required because the directory is not accessible by
other apps, so you can declare the permission should be requested only on
the lower versions of Android by adding the maxSdkVersion attribute:
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="18" />
Note: Files you save in the directories provided by getExternalFilesDir()
are deleted when the user uninstalls your app.

Once you decide the directory for the file, you need to create a collision-
resistant file name. You may wish also to save the path in a member variable
for later use. Here's an example solution in a method that returns a unique
file name for a new photo using a date-time stamp:
    import android.os.Environment;
    import java.util.Date;
    import java.text.SimpleDateFormat;
    import java.io.File;
    import java.io.IOException;

    String mCurrentPhotoPath;
    private File createImageFile() throws IOException {
        // Create an image file name
        String timeStamp = new 
            SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
        String imageFileName = "JPEG_" + timeStamp + "_";
        File storageDir = Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_PICTURES);
        File image = File.createTempFile(
                imageFileName,      /* prefix */
                ".jpg",             /* suffix */
                storageDir          /* directory */
        );

        /* Android在线网址中,这里写的是:
         *     mCurrentPhotoPath = "file:" + image.getAbsolutePath();
         * 实际调试发现,这个写法有问题.添加"file:"是把路径名转化为URI形式.
         * 但是后面的代码会执行 "Uri.fromFile(mCurrentPhotoPath)" 将路径名
         * 转换为URI,也是在路径前面加上"file://",就多了一个"file",会出错.
         */
        mCurrentPhotoPath = image.getAbsolutePath();
        return image;
    }
With this method available to create a file for the photo, you can now
create and invoke the Intent like this:
    import android.net.Uri;

    private void dispathTakePictureIntent() {
        Intent photoIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        // Ensure that there's a camera activity to handle the intent
        if (photoIntent.resolveActivity(getPackageManager()) != null) {
            // Create the File where the photo should go
            File photoFile = null;
            try {
                photoFile = createImageFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
            // Continue only if the File was successfully created
            if (photoFile != null) {
                photoIntent.putExtra(MediaStore.EXTRA_OUTPUT,
                        Uri.fromFile(photoFile));
                startActivityForResult(photoIntent, REQUEST_TAKE_PHOTO);
            }
        }
    }
添加这部分代码后,启动摄像机程序时所拍的照片就会被保存到外部存储(SD卡)上.
注意: 之前的代码在 onActivityResult() 函数中执行 "data.getExtras()" 语句来
获取所拍照片的 Bitmap 对象.在传递保存照片文件的路径给Camera后,Camera再回调
onActivityResult()函数时,传递过来的 data 参数是空.此时,不能再执行
"data.getExtras()"语句,否则触发空指针异常,之前获取Bitmap对象的代码要删掉.

--> Add the Photo to a Gallery
When you create a photo through an intent, you should know where your image
is located, because you said where to save it in the first place. For
everyone else, perhaps the easiest way to make your photo accessible is to
make it accessible from the system's Media Provider.
Note: If you saved your photo to the directory provided by
getExternalFilesDir(), the media scanner cannot access the files because
they are private to your app.

The following example method demonstrates how to invoke the system's media
scanner to add your photo to the Media Provider's database, making it
available in the Android Gallery application and to other apps.
private void galleryAddPicture() {
    Intent scanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
    /* 如果上面的mCurrentPhotoPath多加了"file:",运行时,这里会提示路径名
     * 出错,导致后面的 Intent 扫描不到图片,无法自动添加图片到图库里面.
     */
    File targetFile = new File(mCurrentPhotoPath);
    Uri contentUri = Uri.fromFile(targetFile);
    scanIntent.setData(contentUri);
    this.sendBroadcast(scanIntent);
}

--> Decode a Scaled Image
Managing multiple full-sized images can be tricky with limited memory. If
you find your application running out of memory after displaying just a few
images, you can dramatically reduce the amount of dynamic heap used by
expanding the JPEG into a memory array that's already scaled to match the
size of the destination view. The following example method demonstrates
this technique.
  private void setPicture() {
      // Get the dimensions of the View
      int targetW = mImageView.getWidth();
      int targetH = mImageView.getHeight();
      // Get the dimensions of the bitmap
      BitmapFactory.Options options = new BitmapFactory.Options();
      options.inJustDecodeBounds = true;
      BitmapFactory.decodeFile(mCurrentPhotoPath, options);
      int photoW = options.outWidth;
      int photoH = options.outHeight;

      // Determine how much to scale down the image
      int scaleFactor = Math.min(photoW/targetW, photoH/targetH);

      // Decode the image file into a Bitmap sized to fill the View
      options.inJustDecodeBounds = false;
      options.inSampleSize = scaleFactor;
      options.inPurgeable = true;

      Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, options);
      mImageView.setImageBitmap(bitmap);
  }
注意:这部分代码获取 mImageView 初始的宽度和高度,并作为除数,则 mImageView 的
宽度和高度不能为0,否则会触发"java.lang.ArithmeticException: divide by zero"
的异常.实际调试发现,在布局文件中将mImageView对应的<ImageView>标签的
"android:layout_width"和"android:layout_height"设成"wrap_content"时,其初始
宽度和高度就是0.而设成"match_parent",或者指定具体的值(如"100dp")时,其初始
宽度和高度就不会是0.

#### Recording Videos Simply ####
This lesson explains how to capture video using an existing camera
application. 即,往Android自带的摄像机程序发送 Intent,让它来处理录像请求.

--> Request Camera Permission
和上面拍照时需要申请的权限是一样的.

--> Record a Video with a Camera App
同样和上面拍照时的代码片段类似,只是发送的Intent类型不同而已.
    static final int REQUEST_TAKE_VIDEO = 2;
    private void dispathTakeVideoIntent() {
        Intent videoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
        if (photoIntent.resolveActivity(getPackageManager()) != null) {
            startActivityForResult(videoIntent, REQUEST_TAKE_PHOTO);
        }
    }

--> View the Video
The Android Camera application returns the video in the Intent delivered to
onActivityResult() as a Uri pointing to the video location in storage. The
following code retrieves this video and displays it in a VideoView.
    import android.widget.VideoView;

    @Override
    protected void onActivityResult(int request, int result, Intent data) {
        if (request == REQUEST_TAKE_VIDEO && result == RESULT_OK) {
            Uri videoUri = intent.getData();
            mVideoView.setVideoURI(videoUri);
            // 要执行 start() 函数才会开始播放录好的视频
            mVideoView.start();
        }
    }

#### Controlling the Camera ####
In this lesson, we discuss how to control the camera hardware directly
using the framework APIs.

--> Open the Camera Object
Getting an instance of the Camera object is the first step in the process of
directly controlling the camera. As Android's own Camera application does,
the recommended way to access the camera is to open Camera on a separate
thread that's launched from onCreate(). This approach is a good idea since
it can take a while and might bog down the UI thread. In a more basic
implementation, opening the camera can be deferred to the onResume() method
to facilitate code reuse and keep the flow of control simple.

Calling Camera.open() throws an exception if the camera is already in use
by another application, so we wrap it in a try block.
    import android.hardware.Camera;

    private Camera getCameraInstance(int id) {
        Camera c = null;
        try {
            c = Camera.open(id);    // attempt to get a Camera instance
        } catch (Exception e) {
            // Camera is not available (in use or does not exist)
            e.printStackTrace();
        }
        return c;   // return null if camera is unavailable
    }
Since API level 9, the camera framework supports multiple cameras. If you
use the legacy API and call open() without an argument, you get the first
rear-facing camera. 即, Camera.open() 默认返回后置摄像头的对象.

-> Checking camera features
Once you obtain access to a camera, you can get further information about
its capabilities using the Camera.getParameters() method and checking the
returned Camera.Parameters object for supported capabilities. When using
API Level 9 or higher, use the Camera.getCameraInfo() to determine if a
camera is on the front or back of the device, and the orientation of the
image. If necessary, modify the returned Camera.Parameters object and call
setParameters(Camera.Parameters).

--> Creating a preview class
For users to effectively take pictures or video, they must be able to see
what the device camera sees. A camera preview class is a SurfaceView that
can display the live image data coming from a camera, so users can frame
and capture a picture or video.
实际调试发现,当调用 Camera.open() 函数获取到摄像机对象后,如果立刻调用
    mCamera.setPreviewDisplay(mPreview.getHolder());
    mCamera.startPreview();
来启动预览,预览会失败,logcat中提示:
    D/Camera  (10602): app passed NULL surface
如果获取摄像机对象后,延时一段时间再来启动预览,就能预览成功.由于这个延时不好
把握,所以实现一个继承自 SurfaceView 的类,再对应的回调函数surfaceCreated()中
再来启动预览会更好.这样,传递到 Camera 的 surface 就不会是 NULL.

The following example code demonstrates how to create a basic camera preview
class that can be included in a View layout. This class implements
SurfaceHolder.Callback in order to capture the callback events for creating
and destroying the view, which are needed for assigning the camera preview
input.
实际调试确认,在执行 onResume() 之后,会再执行 surfaceCreated();在执行
onPause() 之后,会再执行 surfaceDestroyed().所以,可以在 surfaceCreated() 中
进行 Camera 对象的初始化,在 surfaceDestroyed() 中释放 Camera 对象.
import android.content.Context;
import android.view.SurfaceView;
import android.view.SurfaceHolder;

/** A basic Camera preview class */
public class CameraPreview extends SurfaceView implements
    SurfaceHolder.Callback {
    private SurfaceHolder mHolder;
    private Camera mCamera;
    
    public CameraPreview(Context context, Camera camera) {
        super(context);
        mCamera = camera;
        // Install a SurfaceHolder.Callback so we get notified when the
        // underlying surface is created and destroyed.
        mHolder = getHolder();
        mHolder.addCallback(this);
        // deprecated setting, but required on Android versions prior to 3.0
        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
    }

    public void surfaceCreated(SurfaceHolder holder) {
        // The Surface has been created, now tell the camera where to
        // draw the preview.
        try {
            mCamera.setPreviewDisplay(holder);
            mCamera.startPreview();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void surfaceDestroyed(SurfaceHolder holder) {
        // empty. Take care of releasing the Camera preview in your activity
    }

    public void surfaceChanged(SurfaceHolder holder, int format,
            int w, int h) {
        // If your preview can change or rotate, take care of those events
        // here. Make sure to stop the preview before resizing or
        // reformatting it.

        if (mHolder.getSurface() == null) {
            // preview surface does not exist
            return;
        }

        // stop preview before making changes
        try {
            mCamera.stopPreview();
        } catch (Exception e) {
            e.printStackTrace();
        }

        // set preview size and make any resize, rotate or
        // reformatting changes here

        // start preview with new settings
        try {
            mCamera.setPreviewDisplay(mHolder);
            mCamera.startPreview();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
If you want to set a specific size for your camera preview, set this in the
surfaceChanged() method as noted in the comments above. When setting preview
size, you must use values from getSupportedPreviewSize(). Do not set
arbitrary values in the setPreviewSize() method.

--> Placing preview in a layout
A camera preview class, such as the example shown in the previous section,
must be placed in the layout of an activity along with other user interface
controls for taking a picture or video. This section shows you how to build
a basic layout and activity for the preview.
The following layout code provides a very basic view that can be used to
display a camera preview. In this example, the FrameLayout element is meant
to be the container for the camera preview class. This layout type is used
so that additional picture information or controls can be overlayed on the
live camera preview images.
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <FrameLayout
        android:id="@+id/camera_preview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_weight="1" />
    <Button
        android:id="@+id/button_capture"
        android:text="Capture"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center" />
/LinearLayout>

On most devices, the default orientation of the camera preview is landscape.
This example layout specifies a horizontal (landscape) layout and the code
below fixes the orientation of the application to landscape. For simplicity
in rendering a camera preview, you should change your application's preview
activity orientation to landscape by adding the following to your manifest.
即,下面这段代码固定摄像机的预览为横屏.
    <activity android:name=".CameraActivity"
        android:label="@string/app_name"
        android:screenOrientation="landscape">
        <!-- configure this activity to use landscape orientation -->
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
Note: A camera preview does not have to be in landscape mode. Starting in
Android 2.2 (API Level 8), you can use the setDisplayOrientation() method
to set the rotation of the preview image. In order to change preview
orientation as the user re-orients the phone, within the surfaceChanged()
method of your preview class, first stop the preview with
Camera.stopPreview() change the orientation and then start the preview
again with Camera.startPreview().

In the activity for your camera view, add your preview class to the
FrameLayout element shown in the example above. Your camera activity must
also ensure that it releases the camera when it is paused or shut down. The
following example shows how to modify a camera activity to attach the
preview class Show in "Creating a preview class".
如上所述,当 Activity 在暂停或者退出时,一定要释放摄像机对象.
import android.widget.FrameLayout;

public class CameraActivity extends Activity {
    private Camera mCamera;
    private CameraPreview mPreview;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // Create an instance of Camera
        mCamera = getCameraInstance();

        // Create our Preview view and set it as the content of our activity
        mPreview = new CameraPreview(this, mCamera);
        FrameLayout preview = (FrameLayout) findViewById(
                R.id.camera_preview);
        preview.addView(mPreview);
    }
}

--> Capturing pictures
Once you have built a preview class and a view layout in which to display
it, you are ready to start capturing images with your application. In your
application code, you must set up listeners for your user interface controls
to respond to a user action by taking a picture.
In order to retrieve a picture, use the Camera.takePicture() method. This
method takes three paramters which receive data from the camera. In order to
receive data in a JPEG format, you must implement an Camera.PictureCallback
interface to receive the image data and write it to a file. The following
code shows a basic implementation of the Camera.PictureCallback interface to
save an image received from the camera.
import android.hardware.Camera.PictureCallback;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;

private PictureCallback mPicture = new PictureCallback() {
    @Override
    public void onPictureTaken(byte[] data, Camera camera) {
        try {
            // getOutputMediaFile() 和 MEDIA_TYPE_IMAGE 在后面的代码中定义
            File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
            if (pictureFile == null) {
                e.printStackTrace();
                return;
            }

            FileOutputStream fos = new FileOutputStream(pictureFile);
            // 将回调过来的摄像机数据写入到文件,从而保存所拍的照片
            fos.write(data);
            fos.close();
        } catch(FileNotFoundException e) {
            Log.d(TAG, "File not found: " + e.getMessage());
        } catch (IOException e) {
            Log.d(TAG, "Error accessing file: " + e.getMessage());
        }
    }
}

Trigger capturing an image by calling the Camera.takePicture() method. The
following example code shows how to call this method from a button
View.OnClickListener.
    // Add a listener to the Capture button
    Button captureButton = (Button) findViewById(R.id.button_capture);
    captureButton.setOnClickListener(
        new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // get an image from the camera
                mCamera.takePicture(null, null, mPicture);
            }
        }
    );
Caution: Remember to release the Camera object by calling the
Camera.release() when your application is done using it!

--> Capturing videos
Video capture using the Android framework requires careful management of the
Camera object and coordination with the MediaRecorder class. When recording
video with Camera, you must manage the Camera.lock() and Camera.unlock()
calls to allow MediaRecorder access to the camera hardware, in addition to
the Camera.open() and Camera.release() calls.

Unlike taking pictures with a device camera, capturing video requires a very
particular call order. You must follow a specific order of execution to
successfully prepare for and capture video with your application, as
detailed below.
1.Open Camera -- Use the Camera.open() to get an instance of the camera
object.
2.Connect Preview -- Prepare a live camera image preview by connecting a
SurfaceView to the camera using Camera.setPreviewDisplay().
3.Start Preview -- Call Camera.startPreview() to begin displaying the live
image images.
4.Start Recording Video -- The following steps must be completed in order
to successfully record video:
    a.Unlock the Camera -- Unlock the camera for use by MediaRecorder by
      calling Camera.unlock().
    b.Configure MediaRecorder -- Call in the following MediaRecorder methods
      in this order.
      1.setCamera() -- Set the camera to be used for video capture, use your
        application's current instance of Camera.
      2.setAudioSource() -- Set the audio source, use
        MediaRecorder.AudioSource.CAMCORDER.
      3.setVideoSource() -- Set the video source, use
        MediaRecorder.VideoSource.CAMERA.
      4.Set the video output format and encoding. For Android 2.2 (API Level
        8) and higher, use the MediaRecorder.setProfile methods, and get a
        profile instance using CamcorderProfile.get().
        网上很多例子采用下面的方式来设置音频和视频编码:
        mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
        mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);
        mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT);
        按照Android在线网址的说法,这适用于Android 2.2 (API Level 8)之前的版
        本.所以在更高版本的Android上,尽量不要使用这种方法.
      5.setOutputFile() -- Set the output file, use getOutputMediaFile(
        MEDIA_TYPE_VIDEO).toString() from the example method in the "Saving
        Media Files" section.
      6.setPreviewDisplay() -- Specify the SurfaceView preview layout
        element for your application. Use the same object you specified
        for "Connect Preview".
        Caution: You must call these MediaRecorder configuration methods in
        this order, otherwise your application will encounter errors and
        the recording will fail.
    c.Prepare MediaRecorder -- Prepare the MediaRecorder with provided
      configuration settings by calling MediaRecorder.prepare().
    d.Start MediaRecorder -- Start recording video by calling
      MediaRecorder.start().
5.Stop Recording Video -- Call the following methods in order, to
successfully complete a video recording:
  a.Stop MediaRecorder -- Stop recording video by calling
    MediaRecorder.stop().
  b.Reset MediaRecorder -- Optionally, remove the configuration settings
    from the recorder by calling MediaRecorder.reset().
  c.Release MediaRecorder -- Release the MediaRecorder by calling
    MediaRecorder.release().
  d.Lock the Camera -- LOck the camera so that future MediaRecorder sessions
    can use it by calling Camera.lock(). Starting with Android 4.0 (API
    level 14), this call is not required unless the MediaRecorder.prepare()
    call fails.
6.Stop the Preview -- When your activity has finished using the camera,
  stop the preview using Camera.release().
Note: It is possible to use MediaRecorder without a camera preview first
and skip the first few steps of this process. However, since uses typically
prefer to see a preview before starting a recording, that process is not
discussed here.
Tip: If your application is typically used for recording video, set
setRecordingHint(boolean) to true prior to starting your preview. This
setting can help reduce the time it takes to start recording.

-> Request Audio Recording Permission
For recording audio with video capture, your application must request the
audio capture permission.
    <uses-permission android:name="android:permission.RECORD_AUDIO" />

-> Configuring MediaRecorder
When using the MediaRecorder class to record video, you must perform
configuration steps in a specific order and then call the
MediaRecorder.prepare() method to check and implement the configuration. The
following example code demonstrates how to properly configure and prepare
the MediaRecorder class for video recording.
注意: 目前认为,在捕获照片时,用的是自定义的CameraPreview类,而在捕获视频时,用
的是原生的SurfaceView类.后面代码定义的mPreview也确实是SurfaceView类.当然,在
捕获视频时,使用自定义的 CameraPreview 类也是可以的.
import android.media.MediaRecorder;
import android.media.CamcorderProfile;

private boolean prepareVideoRecorder() {
    mCamera = getCameraInstance();
    mMediaRecorder = new MediaRecorder();

    // Step 1: Unlock and set camera to MediaRecorder
    mCamera.unlock();
    mMediaRecorder.setCamera(mCamera);

    // Step 2: Set sources
    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);

    // Step 3: Set a CamcorderProfile (requires API Level 8 or higher)
    mMediaRecorder.setProfile(CamcorderProfile.get(
                CamcorderProfile.QUALITY_HIGH));

    // Step 4: Set output file. getOutputMediaFile()函数在后面代码中实现
    mMediaRecorder.setOutputFile(
            getOutputMediaFile(MEDIA_TYPE_VIDEO).toString());

    // Step 5: Set the preview output
    mMediaRecorder.setPreviewDisplay(mPreview.getHolder().getSurface());

    // Step 6: Prepare configured MediaRecorder
    try {
        mMediaRecorder.prepare();
    } catch (IllegalStateException e) {
        e.printStackTrace();
        // releaseMediaRecorder()函数在后面代码中实现
        releaseMediaRecorder();
        return false;
    } catch (IOException e) {
        e.printStackTrace();
        releaseMediaRecorder();
        return false;
    }
    return true;
}
The following video recording parameters for MediaRecorder() are given
default settings, however, you may want to adjust these settings for your
application:
    setVideoEncodingBitRate()
    setVideoSize()
    setVideoFrameRate()
    setAudioEncodingBitRate()
    setAudioChannels()
    setAudioSamplingRate()

-> Starting and stopping MediaRecorder
When starting and stopping video recording using the MediaRecorder class,
you must follow a specific order, as listed below.
1.Unlock the camera with Camera.unlock()
2.Configure MediaRecorder as shown in the code example above
3.Start recording using MediaRecorder.start()
4.Record the video
5.Stop recording using MediaRecorder.stop()
6.Release the media recorder with MediaRecorder.release()
7.Lock the camera using Camera.lock()

The following example code demonstrates how to wire up a button to properly
start and stop video recording using the camera and the MediaRecorder class.
Note: When completing a video recording, do not release the camera or else
your preview will be stopped.
private boolean isRecording = false;

// Add a listener to the Capture button
Button captureButton = (Button) findViewById(R.id.button_capture);
captureButton.setOnClickListener(
    new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            if (isRecording) {
                // stop recording and release camera
                mMediaRecorder.stop();  // stop the recording
                releaseMediaRecorder(); // release the MediaRecorder object
                mCamera.lock();// take camera access back from MediaRecorder

                // inform the user that recording has stopped
                setCaptureButtonText(R.string.capture_text);
                isRecording = false;
            } else {
                // initialize video camera
                if (prepareVideoRecorder()) {
                    // Camera is available and unlocked, MediaRecorder is
                    // prepared, now you can start recording
                    mMediaRecorder.start();

                    // inform the user that recording has started
                    setCaptureButtonText(R.string.stop_text);
                    isRecording = true;
                } else {
                    // prepare didn't work, release the camera
                    releaseMediaRecorder();
                }
            }
        }
    }
);
private void setCaptureButtonText(int id) {
    captureButton.setText(id);
}

-> Release the camera
Cameras are a resource that is shared by applications on a device. Your
application can make use of the camera after getting an instance of Camera,
and you must be particularly careful to release the camera object when your
application stops using it, and as soon as your application is paused
(Activity.onPause()). If your application does not properly release the
camera, all subsequent attempts to access the camera, including those by
your own application, will fail and my cause your or other applications to
shut down.

To release an instance of the Camera object, use the Camera.release()
method, as shown in the example code below.
public class CameraActivity extends Activity {
    private Camera mCamera;
    private SurfaceView mPreview;
    private MediaRecorder mMediaRecorder;

    @Override
    protected void onPause() {
        super.onPause();
        releaseMediaRecorder();
        releaseCamera(); // release the camera immediately on pause event
    }

    private void releaseMediaRecorder() {
        if (mMediaRecorder != null) {
            mMediaRecorder.reset(); // clear recorder configuratioin
            mMediaRecorder.release(); // release the recorder object
            mMediaRecorder = null;
            mCamera.lock(); // lock camera for later use
        }
    }

    private void releaseCamera() {
        if (mCamera != null) {
            mCamera.release(); // release the camera for other applications
            mCamera = null;
        }
    }
}

-> Saving Media Files
Media files created by users such as picture and videos should be saved to
a device's external storage directory (SD Card) to conserve system space
and to allow users to access these files without their device. There are
many possible directory locations to save media files on a device, however
there are only two standard locations you should consider as a developer:
1.Environment.getExternalStoragePublicDirectory(Environment.
  DIRECTORY_PICTURES) - This method returns the standard, shared and
  recommended location for saving pictures and videos. This directory is
  shared (public), so other application can easily discover, read, change
  and delte files save in this location. If your application is uninstalled
  by the user, media files saved to this location will not be removed. To
  avoid interfering with users existing pictures and videos, you should
  create a sub-directory for your application's media files within this
  directory, as shown in the code sample below.
2.Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) - This method
  returns a standard location for saving pictures and videos which are
  associated with your application. If your application is uninstalled, any
  files saved in this location are removed. Security is not enforced for
  files in this location and other application may read, change and delete
  them.

The following example code demonstrates how to create a File or Uri location
for a media file that can be used when invoking a device's camera with an
Intent.
public static final int MEDIA_TYPE_IMAGE = 1;
public static final int MEDIA_TYPE_VIDEO = 2;

/** Create a file Uri for saving an image or video */
private static Uri getOutputMediaFileUri(int type) {
    return Uri.fromFile(getOutputMediaFile(type));
}

/** Create a File for saving an image or video */
private static File getOutputMediaFile(int type) {
    // To be safe, you should check that the SD Card is mounted
    // using Environment.getExternalStorageState() before doing this.
    File mediaDir = new File(Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_PICTURES), "MyCameraApp");
    // This location works best if you want the created images to be shared
    // between applicationa and presist after your app has been uninstalled

    // Create the storage directory if it does not exist
    if (! mediaDir.exists()) {
        if (! mediaDir.mkdirs()) {
            Log.d(TAG, "failed to create directory");
            return null;
        }
    }

    // Create a media file name
    String timeStamp = new 
        SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    File mediaFile;
    if (type == MEDIA_TYPE_IMAGE) {
        mediaFile = new File(mediaDir.getPath() + File.separator +
                "IMG_" + timeStamp + ".jpg");
    } else if (type == MEDIA_TYPE_VIDEO) {
        mediaFile = new File(mediaDir.getPath() + File.separator +
                "VID_" + timeStamp + ".mp4");
    } else {
        return null;
    }
    return mediaFile;
}

#### Camera Features ####
Android supports a wide array of camera features you can control with your
camera application, such as picture format, flash mode, focus settings, and
many more. Most camera features can be accessed and set using the through
Camera.Parameters object.

--> Checking feature availability
The first thing to understand when setting out to use camera features on
Android devices is that not all camera features are supported on all
devices. In addition, devices that supported a particular feature may
support them to different levels or with different options. Therefore, part
of your decision process as you develop a camera application is to decide
what camera features you want to support and to what level. After making
that decision, you should plan on including code in your camera application
that checks to see if device hardware supports those features and fails
gracefully if a feature is not available.

You can check the availability of camera features by getting an instance of
camera's paramters object, and checking the relevant methods. The following
code sample shows you how to obtain a Camera.Parameters object and check if
the camera supports the autofocus feature:
    import java.util.List;

    // get Camera parameters
    Camera.Parameters params = mCamera.getParameters();

    List<String> focusModes = params.getSupportedFocusModes();
    if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
        // Autofocus mode is supported
    }

You can use the technique shown above for most camera features. The
Camera.Parameters object provides a getSupported...(), is...Supported() or
getMax...() method to determine if (and to what extent) a feature is
supported.

If your application requires certain camera features in order to function
properly, youcan require them through additionis to your application
manifest. When you declare the use of specific camera features, such as
flush and auto-focus, Google Play restricts your application from being
installed on devices which do not support these features. 例如:
    <uses-feature android:name="android.hardware.camera.autofocus" />

--> Using camera features
Most camera features are activated and controlled using a Camera.Parameters
object. You obtain this object by fist getting an instance of the Camera
object, calling the getParameters() method, chaning the returned parameter
object and then setting it back into the camera object, as demonstrates in
the following example code:
    // get Camera parameters
    Camera.Parameters params = mCamera.getParameters();
    // set the focus mode
    params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
    // set Camera parameters
    mCamera.setParameters(params);
This technique works for nearly all camera features, and most parameters
can be changed at any time after you have obtained an instance of the
Camera object. Changes to parameters are typically visible to the user
immediately in the application's camera preview. On the software side,
parameter changes may take several frames to actually take effect as the
camera hardware processes the new instructions and then sends updated image
data.
